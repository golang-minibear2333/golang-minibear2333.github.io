<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="简介 #  Goroutine 是 Golang 中非常有用的功能，有时候 goroutine 没执行完函数就返回了，如果希望等待当前的 goroutine 执行完成再接着往下执行，该怎么办？
package main import ( &#34;time&#34; &#34;fmt&#34; ) func say(s string) { for i := 0; i &lt; 3; i&#43;&#43; { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&#34;hello world&#34;) fmt.Println(&#34;over!&#34;) } 输出 over！ , 主线程没有等待
唯一好方案 #  Golang 官方在 sync 包中提供了 WaitGroup 类型来解决这个问题。其文档描述如下：
 A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="" />
<meta property="og:description" content="简介 #  Goroutine 是 Golang 中非常有用的功能，有时候 goroutine 没执行完函数就返回了，如果希望等待当前的 goroutine 执行完成再接着往下执行，该怎么办？
package main import ( &#34;time&#34; &#34;fmt&#34; ) func say(s string) { for i := 0; i &lt; 3; i&#43;&#43; { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&#34;hello world&#34;) fmt.Println(&#34;over!&#34;) } 输出 over！ , 主线程没有等待
唯一好方案 #  Golang 官方在 sync 包中提供了 WaitGroup 类型来解决这个问题。其文档描述如下：
 A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://golang.coding3min.com/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E7%AD%89%E5%BE%85goroutine%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1_%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8goroutine/" /><meta property="article:section" content="番外.常用操作" />



<title>等待goroutine完成任务 循环中使用goroutine | go语言精进之路</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css" integrity="sha256-lYzqeCdiHW&#43;8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.b1a40f32a4547031f4a3870ac13fcb8422b456a06543d385e225dfb4182cafed.js" integrity="sha256-saQPMqRUcDH0o4cKwT/LhCK0VqBlQ9OF4iXftBgsr&#43;0=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/"><img src="/logo.png" alt="Logo" /><span>go语言精进之路</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  <ul>
<li>
  <a href="https://coding3min.com">机智的程序员小熊</a></li>
<li>
  <a href="https://github.com/minibear2333/">GitHub</a></li>
<li>
  <a href="/qrcode/">微信公众号</a></li>
<li><strong>帮助与提示</strong>
<ul>
<li>
  <a href="/howtocontribute/">0.0 如何参与贡献</a></li>
<li>
  <a href="/books-share/">0.1 书籍推荐</a></li>
</ul>
</li>
<li><strong>第一章、Go基础</strong>
<ul>
<li>
  <a href="/1.base/1-1-install-download/">1.1 安装与下载</a></li>
<li>
  <a href="/1.base/1-2-hello-world/">1.2 跑起来</a></li>
<li>
  <a href="/1.base/1-3-go-mod/">1.3 go mod最佳实践</a></li>
<li>
  <a href="/1.base/1-4-variables/">1.4 变量与常量</a></li>
<li>
  <a href="/1.base/1-5-switch%E5%92%8Ctypeswitch/">1.5 switch和type switch</a></li>
<li>
  <a href="/1.base/1-6-for-range/">1.6 循环</a></li>
<li>
  <a href="/1.base/1-7-range%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">1.7 range深度解析</a></li>
</ul>
</li>
<li><strong>第二章、函数和容器</strong>
<ul>
<li>
  <a href="/2.func-containers/2-1-func/">2.1 函数简单使用和基本知识解析</a></li>
<li>
  <a href="/2.func-containers/2-2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/">2.2 匿名函数和闭包</a></li>
<li>
  <a href="/2.func-containers/2-3-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/">2.3 可变参数</a></li>
<li>
  <a href="/2.func-containers/2-4-map/">2.4 集合（map）</a></li>
<li>
  <a href="/2.func-containers/2-5-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">2.5 数组和切片</a></li>
</ul>
</li>
<li><strong>第三章、语法进阶</strong>
<ul>
<li>
  <a href="/3.grammar-advancement/3-1-point/">3.1 指针讨论</a></li>
<li>
  <a href="/3.grammar-advancement/3-2-struct/">3.2 结构体</a></li>
<li>
  <a href="/3.grammar-advancement/3-3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/">3.3 接口与多态</a></li>
<li>
  <a href="/3.grammar-advancement/3-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">3.4 异常处理</a></li>
</ul>
</li>
<li><strong>第四章、并发和并行</strong>
<ul>
<li>
  <a href="/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/">4.1 并发特性</a></li>
<li>
  <a href="/4.concurrent/channel/">4.2 channel</a></li>
<li>
  <a href="/4.concurrent/select/">4.3 select</a></li>
<li>
  <a href="/4.concurrent/timeout/">4.4 设置超时</a></li>
<li>
  <a href="/a.timer/reset/reset-time/">设置可热更新的定时器</a></li>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E7%AD%89%E5%BE%85goroutine%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1_%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8goroutine/"class=active>goroutine等待</a></li>
<li>-并发安全</li>
<li>-协程池</li>
<li>-消费者生产者框架</li>
</ul>
</li>
<li><strong>第五章、标准库</strong>
<ul>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E4%BB%A3%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/">Go代码基本标准规范</a></li>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/">文件操作</a></li>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8Fsort%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/">排序</a></li>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/flag%E5%8C%85%E8%AF%BB%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE/">命令行操作</a></li>
<li>-时间处理</li>
<li>-字符串处理</li>
<li>-json库</li>
<li>-http库</li>
<li>跨平台编译</li>
</ul>
</li>
<li><strong>第六章、性能调优</strong>
<ul>
<li>-cpu调度</li>
<li>-内存管理</li>
<li>-垃圾回收</li>
<li>-PProf</li>
<li>-逃逸分析</li>
<li>-链路追踪</li>
<li>-自监控</li>
</ul>
</li>
<li><strong>第七章、调试与测试</strong>
<ul>
<li>-调试</li>
<li>-单元测试</li>
<li>-mock</li>
<li>-自动化测试</li>
</ul>
</li>
<li><strong>第八章、反射</strong></li>
<li><strong>第九章、优秀开源组件</strong>
<ul>
<li>-日志</li>
<li>-配置管理</li>
<li>-接口文档</li>
<li>-错误码控制</li>
<li>-数据库连接</li>
<li>-为开源项目贡献代码</li>
</ul>
</li>
<li><strong>第十章、分布式系统</strong>
<ul>
<li>-分布式ID生成器</li>
<li>-分布式锁</li>
<li>-分布式一致性算法</li>
</ul>
</li>
<li><strong>第x章、web应用</strong>
<ul>
<li>-GRPC</li>
<li>-Protobuf</li>
</ul>
</li>
<li><strong>第x章、微服务</strong></li>
<li><strong>第x章、服务治理</strong></li>
<li><strong>第x章、GO语言版本分析</strong></li>
<li><strong>番外1、拓展应用</strong>
<ul>
<li>
  <a href="/tools/readme/">小工具</a></li>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/golang%E6%89%93%E9%95%9C%E5%83%8Fdockerfile%E7%9A%84%E5%86%99%E6%B3%95/">Go与Dockerfile</a></li>
</ul>
</li>
<li><strong>番外2、陷阱与缺陷</strong>
<ul>
<li>
  <a href="/impossible/range/readme/">range的第二个值实际上是值拷贝</a></li>
<li>
  <a href="/impossible/%E6%96%B0%E6%89%8B%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/">新手常犯的错误</a></li>
<li>
  <a href="/impossible/%E5%88%9D%E5%AD%A6%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/">初学者常犯的错误</a></li>
<li>
  <a href="/impossible/%E8%BF%9B%E9%98%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/">进阶常犯的错误</a></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>等待goroutine完成任务 循环中使用goroutine</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#唯一好方案">唯一好方案</a></li>
    <li><a href="#引用">引用</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h2 id="简介">
  简介
  <a class="anchor" href="#%e7%ae%80%e4%bb%8b">#</a>
</h2>
<p><code>Goroutine</code> 是 <code>Golang</code> 中非常有用的功能，有时候 <code>goroutine</code> 没执行完函数就返回了，如果希望等待当前的 <code>goroutine</code> 执行完成再接着往下执行，该怎么办？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;time&#34;</span>
    <span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">100</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">say</span>(<span style="color:#e6db74">&#34;hello world&#34;</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;over!&#34;</span>)
}
</code></pre></div><p>输出 <code>over！</code> , 主线程没有等待</p>
<h2 id="唯一好方案">
  唯一好方案
  <a class="anchor" href="#%e5%94%af%e4%b8%80%e5%a5%bd%e6%96%b9%e6%a1%88">#</a>
</h2>
<p>Golang 官方在 sync 包中提供了 WaitGroup 类型来解决这个问题。其文档描述如下：</p>
<blockquote>
<p>A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.</p>
</blockquote>
<p>大意为： <code>WaitGroup</code> 用来等待单个或多个 <code>goroutines</code> 执行结束。在主逻辑中使用 <code>WaitGroup</code> 的 <code>Add</code> 方法设置需要等待的 <code>goroutines</code> 的数量。在每个 goroutine 执行的函数中，需要调用 <code>WaitGroup</code> 的 <code>Done</code> 方法。最后在主逻辑中调用 <code>WaitGroup</code> 的 <code>Wait</code> 方法进行阻塞等待，直到所有 <code>goroutine</code> 执行完成。
使用方法可以总结为下面几点：</p>
<ul>
<li>创建一个 <code>WaitGroup</code> 实例，比如名称为：wg</li>
<li>调用 <code>wg.Add(n)</code> ，其中 n 是等待的 <code>goroutine</code> 的数量</li>
<li>在每个 <code>goroutine</code> 运行的函数中执行 <code>defer wg.Done()</code></li>
<li>调用 <code>wg.Wait()</code> 阻塞主逻辑</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;time&#34;</span>
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">say2</span>(<span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
    <span style="color:#a6e22e">say2</span>(<span style="color:#e6db74">&#34;world&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;over!&#34;</span>)
    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say2</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">waitGroup</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">waitGroup</span>.<span style="color:#a6e22e">Done</span>()

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
    }
}
</code></pre></div><p>简短的例子，注意循环传入的变量用中间变量替代，防止闭包 <code>bug</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(len(<span style="color:#a6e22e">sList</span>))
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">sList</span> {
		<span style="color:#a6e22e">tmpD</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">d</span>
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">waitGroup</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
            <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">waitGroup</span>.<span style="color:#a6e22e">Done</span>()
            <span style="color:#75715e">// to do something
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// use tmpD 
</span><span style="color:#75715e"></span>            }
		}(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</code></pre></div><h2 id="引用">
  引用
  <a class="anchor" href="#%e5%bc%95%e7%94%a8">#</a>
</h2>
<p>
  <a href="https://www.cnblogs.com/sparkdev/p/10917536.html">Golang 入门 : 等待 goroutine 完成任务</a></p>
</article>
 
      <div class="book-footer justify-between"></div>
<hr style="height: 1px;
    background: var(--gray-200);">
<br>
<p>本图书由<a href="https://github.com/minibear2333">小熊</a>©2021 版权所有，<a href="https://golang.coding3min.com/">所有文章</a>采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p>
<div style="text-align:center"><p>	<img width="70%" style="width:70%;height:70%;!important" src="https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png"></p></div>
<script src="https://utteranc.es/client.js"
        repo="minibear2333/blog-comment"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





  <div>
    <a class="flex align-center" href="https://github.com/golang-minibear2333/golang/edit/master/blog/content/%e7%95%aa%e5%a4%96.%e5%b8%b8%e7%94%a8%e6%93%8d%e4%bd%9c/%e7%ad%89%e5%be%85goroutine%e5%ae%8c%e6%88%90%e4%bb%bb%e5%8a%a1_%e5%be%aa%e7%8e%af%e4%b8%ad%e4%bd%bf%e7%94%a8goroutine.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#唯一好方案">唯一好方案</a></li>
    <li><a href="#引用">引用</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












