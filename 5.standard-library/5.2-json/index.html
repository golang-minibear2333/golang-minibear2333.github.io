<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="json处理 #  日常工作中，最常用的数据传输格式就是json，而encoding/json库是内置做解析的库。这一节来看看它的用法，还有几个日常使用中隐晦的陷阱和处理技巧。
json与struct #  一个常见的接口返回内容如下：
{ &#34;data&#34;: { &#34;items&#34;: [ { &#34;_id&#34;: 2 } ], &#34;total_count&#34;: 1 }, &#34;message&#34;: &#34;&#34;, &#34;result_code&#34;: 200 } 在golang中往往是要把json格式转换成结构体对象使用的。 新版Goland粘贴json会自动生成结构体，也可以在 http://json2struct.mervine.net 获得 json 到struct的自动转换。
type ResponseData struct { Data struct { Items []struct { Id int `json:&#34;_id&#34;` } `json:&#34;items&#34;` TotalCount int `json:&#34;total_count&#34;` } `json:&#34;data&#34;` Message string `json:&#34;message&#34;` ResultCode int `json:&#34;result_code&#34;` } 用反斜杠加注解的方式表明属于json中哪个字段，要注意不应该嵌套层数过多，难以阅读容易出错。
一般把内部结构体提出来，可能会另做他用。
type ResponseData struct { Data struct { Items []Body `json:&#34;items&#34;` TotalCount int64 `json:&#34;total_count&#34;` } `json:&#34;data&#34;` Message string `json:&#34;message&#34;` ResultCode int64 `json:&#34;result_code&#34;` } type Body struct { ID int `json:&#34;_id&#34;` } 解析 #  解析就是json字符串，转struct类型。如下，第一个参数为字节数组，第二个为接收的结构体实体地址。如有报错返回错误信息，如没有返回nil。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="json处理 #  日常工作中，最常用的数据传输格式就是json，而encoding/json库是内置做解析的库。这一节来看看它的用法，还有几个日常使用中隐晦的陷阱和处理技巧。
json与struct #  一个常见的接口返回内容如下：
{ &#34;data&#34;: { &#34;items&#34;: [ { &#34;_id&#34;: 2 } ], &#34;total_count&#34;: 1 }, &#34;message&#34;: &#34;&#34;, &#34;result_code&#34;: 200 } 在golang中往往是要把json格式转换成结构体对象使用的。 新版Goland粘贴json会自动生成结构体，也可以在 http://json2struct.mervine.net 获得 json 到struct的自动转换。
type ResponseData struct { Data struct { Items []struct { Id int `json:&#34;_id&#34;` } `json:&#34;items&#34;` TotalCount int `json:&#34;total_count&#34;` } `json:&#34;data&#34;` Message string `json:&#34;message&#34;` ResultCode int `json:&#34;result_code&#34;` } 用反斜杠加注解的方式表明属于json中哪个字段，要注意不应该嵌套层数过多，难以阅读容易出错。
一般把内部结构体提出来，可能会另做他用。
type ResponseData struct { Data struct { Items []Body `json:&#34;items&#34;` TotalCount int64 `json:&#34;total_count&#34;` } `json:&#34;data&#34;` Message string `json:&#34;message&#34;` ResultCode int64 `json:&#34;result_code&#34;` } type Body struct { ID int `json:&#34;_id&#34;` } 解析 #  解析就是json字符串，转struct类型。如下，第一个参数为字节数组，第二个为接收的结构体实体地址。如有报错返回错误信息，如没有返回nil。"><meta property="og:type" content="article"><meta property="og:url" content="https://golang.coding3min.com/5.standard-library/5.2-json/"><meta property="article:section" content="5.standard-library"><title>5.2 JSON | Go语言精进之路</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.02ec527db607b39d727ec5053b57945187642f76c38830f482e370d2ce35fe8e.js integrity="sha256-AuxSfbYHs51yfsUFO1eUUYdkL3bDiDD0guNw0s41/o4=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>Go语言精进之路</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://coding3min.com>机智的程序员小熊</a></li><li><a href=https://github.com/minibear2333/>GitHub</a></li><li><a href=/qrcode/>微信公众号</a></li><li><strong>帮助与提示</strong><ul><li><a href=/howtocontribute/>0.0 如何参与贡献</a></li><li><a href=/books-share/>0.1 书籍推荐</a></li></ul></li><li><strong>————基础篇————</strong></li><li><strong>第一章、Go基础</strong><ul><li><a href=/1.base/1-1-install-download/>1.1 安装与下载</a></li><li><a href=/1.base/1-2-hello-world/>1.2 跑起来</a></li><li><a href=/1.base/1-3-go-mod/>1.3 go mod最佳实践</a></li><li><a href=/1.base/1-4-variables/>1.4 变量与常量</a></li><li><a href=/1.base/1-5-switch%E5%92%8Ctypeswitch/>1.5 switch和type switch</a></li><li><a href=/1.base/1-6-for-range/>1.6 循环</a></li><li><a href=/1.base/1-7-range%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/>1.7 range深度解析</a></li></ul></li><li><strong>第二章、函数和容器</strong><ul><li><a href=/2.func-containers/2-1-func/>2.1 函数简单使用和基本知识解析</a></li><li><a href=/2.func-containers/2-2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/>2.2 匿名函数和闭包</a></li><li><a href=/2.func-containers/2-3-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/>2.3 可变参数</a></li><li><a href=/2.func-containers/2-4-map/>2.4 集合（map）</a></li><li><a href=/2.func-containers/2-5-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/>2.5 数组和切片</a></li></ul></li><li><strong>第三章、语法进阶</strong><ul><li><a href=/3.grammar-advancement/3-1-point/>3.1 指针讨论</a></li><li><a href=/3.grammar-advancement/3-2-struct/>3.2 结构体</a></li><li><a href=/3.grammar-advancement/3-3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/>3.3 接口与多态</a></li><li><a href=/3.grammar-advancement/3-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/>3.4 异常处理</a></li><li>-反射 TODO</li></ul></li><li><strong>第四章、并发和并行</strong><ul><li><a href=/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/>4.1 并发特性</a></li><li><a href=/4.concurrent/4-2-goroutine-wait/>4.2 并发等待</a></li><li><a href=/4.concurrent/4-3-channel/>4.3 channel</a></li><li><a href=/4.concurrent/4-4-deadlock/>4.4 deadlock</a></li><li><a href=/4.concurrent/4-5-select/>4.5 select</a></li><li><a href=/4.concurrent/4-6-cron/>4.6 定时器</a></li><li><a href=/4.concurrent/4-7-lock/>4.7 并发安全和锁</a></li><li>-原子操作 TODO</li><li>-并发安全与类型 TODO</li><li>-协程池 TODO</li><li>-消费者生产者框架 TODO</li><li>-GMP调度原理 TODO</li></ul></li><li><strong>————框架篇————</strong></li><li><strong>第五章、常用标准库</strong><ul><li><a href=5.standard-library/5.1-Go%e4%bb%a3%e7%a0%81%e5%9f%ba%e6%9c%ac%e6%a0%87%e5%87%86%e8%a7%84%e8%8c%83>5.1 Go代码基本标准规范</a></li><li><a href=5.standard-library/5.2-json>5.2 json库</a></li><li><a href=5.standard-library/5.3-Go%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c%e5%a4%a7%e5%85%a8>5.3 文件操作</a></li><li><a href=/5.standard-library/%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8Fsort%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/>5.3 排序</a></li><li><a href=5.standard-library/flag%e5%8c%85%e8%af%bb%e5%8f%96%e5%91%bd%e4%bb%a4%e8%a1%8c%e9%85%8d%e7%bd%ae>5.4 命令行操作</a></li><li>-时间处理 TODO</li><li>-字符串处理 TODO</li><li>-跨平台编译 TODO</li><li>-模板 TODO</li><li>-在线工具系统实战 TODO</li></ul></li><li><strong>第x章、常用数据操作</strong><ul><li>-mysql</li><li>-redis</li><li>-mongo</li><li>-rabbitmq</li><li>-kafka</li><li>-etcd</li><li>-rabbitmq</li><li>-zookeeper</li><li>-ElasticSearch</li></ul></li><li><strong>第x章、常用第三方包</strong><ul><li>-日志</li><li>-配置管理</li><li>-接口文档</li><li>-错误码控制</li></ul></li><li><strong>————测试调试篇————</strong></li><li><strong>第x章、调试与测试</strong><ul><li><a href=https://mp.weixin.qq.com/s/ltRpuolYuOa8cXivLZLlUw>单元测试</a></li><li>-基准测试</li><li>-mock</li><li>-自动化测试</li><li>-调试</li></ul></li><li><strong>第x章、性能调优</strong><ul><li>-cpu调度</li><li>-内存管理</li><li>-垃圾回收</li><li>-PProf</li><li>-逃逸分析</li><li>-链路追踪</li></ul></li><li><strong>————网络编程篇————</strong></li><li><strong>第x章、HTTP框架</strong><ul><li>-http库实现GET POST PUT DEL请求</li><li>-websocket实现在线聊天室</li><li>-常用API框架</li><li>-gin框架实现SSO单点登陆系统</li><li>-beego实现博客</li><li>-buffalo实现变更发布系统</li><li>-echo实现工单管理系统</li><li>-Iris实现</li><li>-revel实现</li></ul></li><li><strong>第x章、RPC</strong></li><li><strong>第x章、微服务</strong><ul><li>熔断与限流</li></ul></li><li><strong>第x章、爬虫实战</strong></li><li><strong>第x章、分布式系统</strong><ul><li>-分布式ID生成器</li><li>-分布式锁</li><li>-分布式一致性算法</li><li>-分布式定时任务</li><li>-分布式计算</li></ul></li><li><strong>————工程化篇————</strong></li><li><strong>第x章、Go语言工程化实战</strong><ul><li>构建约束</li><li><a href=/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/golang%E6%89%93%E9%95%9C%E5%83%8Fdockerfile%E7%9A%84%E5%86%99%E6%B3%95/>Go与Dockerfile</a></li></ul></li><li><strong>第x章、Go语言运维实战</strong></li><li><strong>第x章、Go语言监控实战</strong><ul><li>-自监控</li></ul></li><li><strong>————拓展学习————</strong></li><li><strong>第x章、kubernetes开发实战</strong></li><li><strong>第x章、服务治理</strong></li><li><strong>番外1、拓展应用</strong><ul><li><a href=/tools/readme/>小工具</a></li></ul></li><li><strong>番外2、陷阱与缺陷</strong><ul><li><a href=/impossible/range/readme/>range的第二个值实际上是值拷贝</a></li><li><a href=/impossible/%E6%96%B0%E6%89%8B%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>新手常犯的错误</a></li><li><a href=/impossible/%E5%88%9D%E5%AD%A6%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>初学者常犯的错误</a></li><li><a href=/impossible/%E8%BF%9B%E9%98%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>进阶常犯的错误</a></li></ul></li><li><strong>第x章、GO语言版本分析</strong></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>5.2 JSON</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#json与struct>json与struct</a></li><li><a href=#解析>解析</a></li><li><a href=#反解析>反解析</a></li><li><a href=#陷阱1忘记取地址>陷阱1、忘记取地址</a></li><li><a href=#陷阱2大小写>陷阱2、大小写</a></li><li><a href=#陷阱3十六进制或其他非-utf8-字符串>陷阱3、十六进制或其他非 UTF8 字符串</a></li><li><a href=#陷阱四数字转interface>陷阱四、数字转interface</a></li><li><a href=#技巧版本变更兼容>技巧、版本变更兼容</a></li><li><a href=#小结>小结</a></li></ul></nav></aside></header><article class=markdown><h1 id=json处理>json处理
<a class=anchor href=#json%e5%a4%84%e7%90%86>#</a></h1><p>日常工作中，最常用的数据传输格式就是<code>json</code>，而<code>encoding/json</code>库是内置做解析的库。这一节来看看它的用法，还有几个日常使用中隐晦的陷阱和处理技巧。</p><h2 id=json与struct>json与struct
<a class=anchor href=#json%e4%b8%8estruct>#</a></h2><p>一个常见的接口返回内容如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:#f92672>&#34;data&#34;</span>: {
    <span style=color:#f92672>&#34;items&#34;</span>: [
      {
        <span style=color:#f92672>&#34;_id&#34;</span>: <span style=color:#ae81ff>2</span>
      }
    ],
    <span style=color:#f92672>&#34;total_count&#34;</span>: <span style=color:#ae81ff>1</span>
  },
  <span style=color:#f92672>&#34;message&#34;</span>: <span style=color:#e6db74>&#34;&#34;</span>,
  <span style=color:#f92672>&#34;result_code&#34;</span>: <span style=color:#ae81ff>200</span>
}
</code></pre></div><p>在<code>golang</code>中往往是要把<code>json</code>格式转换成结构体对象使用的。 新版<code>Goland</code>粘贴<code>json</code>会自动生成结构体，也可以在 <a href=http://json2struct.mervine.net>http://json2struct.mervine.net</a> 获得 <code>json</code> 到<code>struct</code>的自动转换。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ResponseData</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Data</span> <span style=color:#66d9ef>struct</span> {
		<span style=color:#a6e22e>Items</span> []<span style=color:#66d9ef>struct</span> {
			<span style=color:#a6e22e>Id</span> <span style=color:#66d9ef>int</span> <span style=color:#e6db74>`json:&#34;_id&#34;`</span>
		} <span style=color:#e6db74>`json:&#34;items&#34;`</span>
		<span style=color:#a6e22e>TotalCount</span> <span style=color:#66d9ef>int</span> <span style=color:#e6db74>`json:&#34;total_count&#34;`</span>
	} <span style=color:#e6db74>`json:&#34;data&#34;`</span>
	<span style=color:#a6e22e>Message</span>    <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;message&#34;`</span>
	<span style=color:#a6e22e>ResultCode</span> <span style=color:#66d9ef>int</span>    <span style=color:#e6db74>`json:&#34;result_code&#34;`</span>
}
</code></pre></div><p>用反斜杠加注解的方式表明属于<code>json</code>中哪个字段，要注意不应该嵌套层数过多，难以阅读容易出错。</p><p>一般把内部结构体提出来，可能会另做他用。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ResponseData</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Data</span> <span style=color:#66d9ef>struct</span> {
		<span style=color:#a6e22e>Items</span> []<span style=color:#a6e22e>Body</span> <span style=color:#e6db74>`json:&#34;items&#34;`</span>
		<span style=color:#a6e22e>TotalCount</span> <span style=color:#66d9ef>int64</span> <span style=color:#e6db74>`json:&#34;total_count&#34;`</span>
	} <span style=color:#e6db74>`json:&#34;data&#34;`</span>
	<span style=color:#a6e22e>Message</span>    <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;message&#34;`</span>
	<span style=color:#a6e22e>ResultCode</span> <span style=color:#66d9ef>int64</span>  <span style=color:#e6db74>`json:&#34;result_code&#34;`</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Body</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>ID</span> <span style=color:#66d9ef>int</span> <span style=color:#e6db74>`json:&#34;_id&#34;`</span>
}
</code></pre></div><h2 id=解析>解析
<a class=anchor href=#%e8%a7%a3%e6%9e%90>#</a></h2><p>解析就是<code>json</code>字符串，转<code>struct</code>类型。如下，第一个参数为字节数组，第二个为接收的结构体实体地址。如有报错返回错误信息，如没有返回<code>nil</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>//函数签名
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>data</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span>
<span style=color:#75715e>// 用法
</span><span style=color:#75715e></span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>([]byte(<span style=color:#a6e22e>jsonStr</span>), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>responseData</span>)
</code></pre></div><p>完整代码如下</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>foo</span>() {
	<span style=color:#a6e22e>jsonStr</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>`{&#34;data&#34;:{&#34;items&#34;:[{&#34;_id&#34;:2}],&#34;total_count&#34;:1},&#34;message&#34;:&#34;&#34;,&#34;result_code&#34;:200}`</span>
	<span style=color:#75715e>//把string解析成struct
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>responseData</span> <span style=color:#a6e22e>ResponseData</span>
	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>([]byte(<span style=color:#a6e22e>jsonStr</span>), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>responseData</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;parseJson error:&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>responseData</span>)
}
</code></pre></div><p>输出如下，和<code>java</code>的<code>toString</code>不同，直接输出了值，如有需要要自行实现并绑定<code>ToString</code>方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>{{[{<span style=color:#ae81ff>2</span>}] <span style=color:#ae81ff>1</span>}  <span style=color:#ae81ff>200</span>}
</code></pre></div><h2 id=反解析>反解析
<a class=anchor href=#%e5%8f%8d%e8%a7%a3%e6%9e%90>#</a></h2><p>第一步，复习初始化结构体的方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ResponseData</span>{
    <span style=color:#a6e22e>Data</span>: <span style=color:#66d9ef>struct</span> {
        <span style=color:#a6e22e>Items</span>      []<span style=color:#a6e22e>Body</span> <span style=color:#e6db74>`json:&#34;items&#34;`</span>
        <span style=color:#a6e22e>TotalCount</span> <span style=color:#66d9ef>int64</span>  <span style=color:#e6db74>`json:&#34;total_count&#34;`</span>
    }{
        <span style=color:#a6e22e>Items</span>: []<span style=color:#a6e22e>Body</span>{
            {<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>1</span>},
            {<span style=color:#a6e22e>ID</span>: <span style=color:#ae81ff>2</span>},
        },
        <span style=color:#a6e22e>TotalCount</span>: <span style=color:#ae81ff>1</span>,
    },
    <span style=color:#a6e22e>Message</span>:    <span style=color:#e6db74>&#34;&#34;</span>,
    <span style=color:#a6e22e>ResultCode</span>: <span style=color:#ae81ff>200</span>,
}
</code></pre></div><p>如上，无类型的结构体<code>Data</code>需要明确把类型再写一遍，再为其赋值。<code>[]Body</code>内直接赋值列表。</p><p>反解析函数签名如下，传入结构体，返回编码好的<code>[]byte</code>，和可能的报错信息。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>)
</code></pre></div><p>完整代码如下</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>bar</span>() {
	<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ResponseData</span>{
		<span style=color:#f92672>...</span>.
	}
	<span style=color:#75715e>//把struct编译成string
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>resBytes</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>r</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;convertJson error: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
	}
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(string(<span style=color:#a6e22e>resBytes</span>))
}
</code></pre></div><p>输出</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>{<span style=color:#e6db74>&#34;data&#34;</span>:{<span style=color:#e6db74>&#34;items&#34;</span>:[{<span style=color:#e6db74>&#34;_id&#34;</span>:<span style=color:#ae81ff>1</span>},{<span style=color:#e6db74>&#34;_id&#34;</span>:<span style=color:#ae81ff>2</span>}],<span style=color:#e6db74>&#34;total_count&#34;</span>:<span style=color:#ae81ff>1</span>},<span style=color:#e6db74>&#34;message&#34;</span>:<span style=color:#e6db74>&#34;&#34;</span>,<span style=color:#e6db74>&#34;result_code&#34;</span>:<span style=color:#ae81ff>200</span>}
</code></pre></div><h2 id=陷阱1忘记取地址>陷阱1、忘记取地址
<a class=anchor href=#%e9%99%b7%e9%98%b11%e5%bf%98%e8%ae%b0%e5%8f%96%e5%9c%b0%e5%9d%80>#</a></h2><p>解析的代码，结尾处应该是<code>&responseData)</code> 忘记取地址会导致无法赋值成功，返回报错。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>([]byte(<span style=color:#a6e22e>jsonStr</span>), <span style=color:#a6e22e>responseData</span>)
</code></pre></div><p>输出报错</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>json</span>: <span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>non</span><span style=color:#f92672>-</span><span style=color:#a6e22e>pointer</span> <span style=color:#a6e22e>main</span>.<span style=color:#a6e22e>ResponseData</span>)
</code></pre></div><h2 id=陷阱2大小写>陷阱2、大小写
<a class=anchor href=#%e9%99%b7%e9%98%b12%e5%a4%a7%e5%b0%8f%e5%86%99>#</a></h2><p>定义一个简单的结构体来演示这个陷阱。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>People</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;name&#34;`</span>
	<span style=color:#a6e22e>age</span>  <span style=color:#66d9ef>int</span>    <span style=color:#e6db74>`json:&#34;age&#34;`</span>
}
</code></pre></div><p>变量如果需要被外部使用，也就是<code>java</code>中的<code>public</code>权限，定义时首字母用大写就可以实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>People</span> <span style=color:#66d9ef>struct</span>
</code></pre></div><p>要用来解析<code>json</code>的<code>struct</code>内部假如使用了小写作为变量名，会导致无法解析成功，而且不会报错！</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>err1</span>() {
	<span style=color:#a6e22e>reqJson</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>`{&#34;name&#34;:&#34;minibear2333&#34;,&#34;age&#34;:26}`</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>person</span> <span style=color:#a6e22e>People</span>
	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>([]byte(<span style=color:#a6e22e>reqJson</span>), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>person</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {<span style=color:#f92672>...</span>}
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>person</span>)
}
</code></pre></div><p>输出，没有成功取到<code>age</code>字段。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>{<span style=color:#a6e22e>minibear2333</span> <span style=color:#ae81ff>0</span>}
</code></pre></div><p>这是因为标准库中是使用反射来获取的，私有字段是无法获取到的，所以内部不知道有这个字段，自然无法显示报错信息。</p><p>我以前没有用自动解析，手敲上去结构体，很容易出现这样的问题，无论如何漏掉某个字段。好在编译器会有提示。</p><p><img src=https://coding3min.oss-accelerate.aliyuncs.com/2021/07/31/R5vaRr.png alt></p><h2 id=陷阱3十六进制或其他非-utf8-字符串>陷阱3、十六进制或其他非 UTF8 字符串
<a class=anchor href=#%e9%99%b7%e9%98%b13%e5%8d%81%e5%85%ad%e8%bf%9b%e5%88%b6%e6%88%96%e5%85%b6%e4%bb%96%e9%9d%9e-utf8-%e5%ad%97%e7%ac%a6%e4%b8%b2>#</a></h2><p>Go 默认使用的字符串编码是 UTF8 编码的。直接解析会出错</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>err2</span>() {
	<span style=color:#a6e22e>raw</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#e6db74>`{&#34;name&#34;:&#34;\xc2&#34;}`</span>)
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>person</span> <span style=color:#a6e22e>People</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>raw</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>person</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
	}
}
</code></pre></div><p>输出</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>invalid</span> <span style=color:#a6e22e>character</span> <span style=color:#e6db74>&#39;x&#39;</span> <span style=color:#a6e22e>in</span> <span style=color:#66d9ef>string</span> <span style=color:#a6e22e>escape</span> <span style=color:#a6e22e>code</span>
</code></pre></div><p>加上反斜杠转义可以成功，或者使用<code>base64</code>编码成字符串，要特别注意这一点，一下子就体现出单元测试的重要性了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>raw</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#e6db74>`{&#34;name&#34;:&#34;\\xc2&#34;}`</span>)
<span style=color:#a6e22e>raw</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#e6db74>`{&#34;name&#34;:&#34;wg==&#34;}`</span>)
</code></pre></div><p>其他需要注意的是编码如果不是<code>UTF-8</code>格式，那么<code>Go</code>会用 <code>�</code> (<code>U+FFFD</code>) 来代替无效的 UTF8，不会报错，但是获得的字符串可能不是你需要的结果。</p><h2 id=陷阱四数字转interface>陷阱四、数字转interface
<a class=anchor href=#%e9%99%b7%e9%98%b1%e5%9b%9b%e6%95%b0%e5%ad%97%e8%bd%acinterface>#</a></h2><p>因为默认编码无类型数字视为 <code>float64</code> 。如果想用类型判断语句为<code>int</code>会直接<code>panic</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>err4</span>() {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> = []byte(<span style=color:#e6db74>`{&#34;age&#34;: 26}`</span>)
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>result</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{}
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>status</span> = <span style=color:#a6e22e>result</span>[<span style=color:#e6db74>&#34;age&#34;</span>].(<span style=color:#66d9ef>int</span>) <span style=color:#75715e>//error
</span><span style=color:#75715e></span>}
</code></pre></div><ul><li>上面的代码隐含一个知识点，<code>json</code>中<code>value</code>是简单类型时，可以直接解析成字典。</li><li>如果有嵌套，那么内部类型也会解析成字典。</li></ul><p>运行时 Panic:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>panic</span>: <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>conversion</span>: <span style=color:#66d9ef>interface</span> {} <span style=color:#a6e22e>is</span> <span style=color:#66d9ef>float64</span>, <span style=color:#a6e22e>not</span> <span style=color:#66d9ef>int</span>

<span style=color:#a6e22e>goroutine</span> <span style=color:#ae81ff>1</span> [<span style=color:#a6e22e>running</span>]:
<span style=color:#a6e22e>main</span>.<span style=color:#a6e22e>err4</span>()
</code></pre></div><ul><li>可以先转换成<code>float64</code>再转换成<code>int</code></li><li>其实还有几种方法，太麻烦了没有必要，就不做介绍了。</li></ul><h2 id=技巧版本变更兼容>技巧、版本变更兼容
<a class=anchor href=#%e6%8a%80%e5%b7%a7%e7%89%88%e6%9c%ac%e5%8f%98%e6%9b%b4%e5%85%bc%e5%ae%b9>#</a></h2><p>你有没有遇到过一种场景，一个接口更新了版本，把<code>json</code>的某个字段变更了，在请求的时候每次都定义两套<code>struct</code>。</p><p>比如<code>Age</code>在版本1中是<code>int</code>在版本2中是<code>string</code>，解析的过程中就会出错。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>json</span>: <span style=color:#a6e22e>cannot</span> <span style=color:#a6e22e>unmarshal</span> <span style=color:#a6e22e>number</span> <span style=color:#a6e22e>into</span> <span style=color:#a6e22e>Go</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>field</span> <span style=color:#a6e22e>People</span>.<span style=color:#a6e22e>age</span> <span style=color:#a6e22e>of</span> <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>string</span>
</code></pre></div><p>我在下面介绍一个技巧，可以省去每次解析都要转换的工作。</p><p>我在源码里面看到，无论反射获得的是哪种类型都会去调用相应的解析接口<code>UnmarshalJSON</code>。</p><p>结合前面的知识，在<code>Go</code>里面看起来像鸭子就是鸭子，我们只要实现这个方法，并绑定到结构体对象上，就可以让源码来调用我们的方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>People</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;name&#34;`</span>
    <span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int</span>    <span style=color:#e6db74>`json:&#34;_&#34;`</span>
}
<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>People</span>) <span style=color:#a6e22e>UnmarshalJSON</span>(<span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#f92672>...</span>
}
</code></pre></div><ul><li>使用下划线，表示此类型不解析。</li><li>必须用指针的方式绑定方法。</li><li>必须与interface{}中定义的方法签名完全一致。</li></ul><p>一共有四个步骤</p><p>1、定义临时类型。用来接受非<code>json:"_"</code>的字段，注意用的是<code>type</code>关键字。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>tmp</span> <span style=color:#a6e22e>People</span>
</code></pre></div><p>2、用中间变量接收json串，tmp以外的字段用来接受<code>json:"_"</code>属性字段</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s</span> = <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>tmp</span>
    <span style=color:#75715e>// interface{}类型，这样才可以接收任意字段
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>Age</span> <span style=color:#66d9ef>interface</span>{} <span style=color:#e6db74>`json:&#34;age&#34;`</span>
}{}
<span style=color:#75715e>// 解析
</span><span style=color:#75715e></span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>b</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>)
</code></pre></div><p>3、判断真实类型，并类型转换</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Age</span>.(<span style=color:#66d9ef>type</span>) {
<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>string</span>:
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>age</span> <span style=color:#66d9ef>int</span>
    <span style=color:#a6e22e>age</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Atoi</span>(<span style=color:#a6e22e>t</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {<span style=color:#f92672>...</span>}
    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>tmp</span>.<span style=color:#a6e22e>Age</span> = <span style=color:#a6e22e>age</span>
<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>float64</span>:
    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>tmp</span>.<span style=color:#a6e22e>Age</span> = int(<span style=color:#a6e22e>t</span>)
}
</code></pre></div><p>4、tmp类型转换回People，并赋值</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>*</span><span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>People</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>tmp</span>)
</code></pre></div><h2 id=小结>小结
<a class=anchor href=#%e5%b0%8f%e7%bb%93>#</a></h2><p>通过本节，我们掌握了标准库中<code>json</code>解析和反解析的方法，以及很有可能日常工作中踩到的几个坑。</p><p>最后分享了一个技巧，实际使用中，这个技巧更加灵活。</p><p>留一个作业：假如有<code>v1</code>和<code>v2</code>不同的两个版本<code>json</code>几乎完成不同，业务逻辑已经使用<code>v1</code>版本，是否可以把<code>v2</code>版本转换成<code>v1</code>版本，不用改动业务逻辑？</p><p>提示： 可以通过深拷贝把<code>v2</code>版本解析出来的结构体完全转换成<code>v1</code>版本的结构体。
要求：必须使用实现 <code>UnmarshalJSON</code>的技巧。</p></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=minibear2333/blog-comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/golang-minibear2333/golang/edit/master/./5.standard-library/5.2-json.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#json与struct>json与struct</a></li><li><a href=#解析>解析</a></li><li><a href=#反解析>反解析</a></li><li><a href=#陷阱1忘记取地址>陷阱1、忘记取地址</a></li><li><a href=#陷阱2大小写>陷阱2、大小写</a></li><li><a href=#陷阱3十六进制或其他非-utf8-字符串>陷阱3、十六进制或其他非 UTF8 字符串</a></li><li><a href=#陷阱四数字转interface>陷阱四、数字转interface</a></li><li><a href=#技巧版本变更兼容>技巧、版本变更兼容</a></li><li><a href=#小结>小结</a></li></ul></nav></div></aside></main></body></html>