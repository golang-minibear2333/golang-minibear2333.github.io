<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="初学者常犯的错误 #   引用： Go 经典译文：50 个 Go 新手易犯的错误（2020版）
 索引运算符和字符串 #  字符串上的 index 方法 （运算符） 返回一个字节值，而不是一个字符类型（就像在其他语言中一样）。
package main import &#34;fmt&#34; func main() { x := &#34;text&#34; fmt.Println(x[0]) //print 116  fmt.Printf(&#34;%T&#34;,x[0]) //prints uint8 } 如果需要访问特定字符串 “characters”（unicode 代码点 / 运行符），请使用 for range 语句。官方的 “unicode/utf8” 包和基础的 utf8string 包 （golang.org/x/exp/utf8string） 也很有用。utf8string 包有一个方便的 At() 方法，将字符串转换为切片也是一种选择。
使用 「for range」子句遍历 Map #   level：初学者  如果你希望 Map 每项数据按照顺序排列 （例如，按键值顺序），这是不可能的，每次 Map 迭代会输出不一样的结果。GO 运行时可能会随机分配迭代顺序，因此你可能会得到几次相同的 Map 迭代结果也不用惊讶。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="初学者常犯的错误 #   引用： Go 经典译文：50 个 Go 新手易犯的错误（2020版）
 索引运算符和字符串 #  字符串上的 index 方法 （运算符） 返回一个字节值，而不是一个字符类型（就像在其他语言中一样）。
package main import &#34;fmt&#34; func main() { x := &#34;text&#34; fmt.Println(x[0]) //print 116  fmt.Printf(&#34;%T&#34;,x[0]) //prints uint8 } 如果需要访问特定字符串 “characters”（unicode 代码点 / 运行符），请使用 for range 语句。官方的 “unicode/utf8” 包和基础的 utf8string 包 （golang.org/x/exp/utf8string） 也很有用。utf8string 包有一个方便的 At() 方法，将字符串转换为切片也是一种选择。
使用 「for range」子句遍历 Map #   level：初学者  如果你希望 Map 每项数据按照顺序排列 （例如，按键值顺序），这是不可能的，每次 Map 迭代会输出不一样的结果。GO 运行时可能会随机分配迭代顺序，因此你可能会得到几次相同的 Map 迭代结果也不用惊讶。"><meta property="og:type" content="article"><meta property="og:url" content="https://golang.coding3min.com/impossible/%E5%88%9D%E5%AD%A6%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/"><meta property="article:section" content="impossible"><title>初学者常犯的错误 | Go语言精进之路</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.20b335f48235bc763e1b5d9bf91beaa5af4f8a539eb51c5e4991502fab81c227.js integrity="sha256-ILM19II1vHY+G12b+Rvqpa9PilOetRxeSZFQL6uBwic=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>Go语言精进之路</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://coding3min.com>机智的程序员小熊</a></li><li><a href=https://github.com/minibear2333/>GitHub</a></li><li><a href=/qrcode/>微信公众号</a></li><li><strong>帮助与提示</strong><ul><li><a href=/howtocontribute/>0.0 如何参与贡献</a></li><li><a href=/books-share/>0.1 书籍推荐</a></li></ul></li><li><strong>第一章、Go基础</strong><ul><li><a href=/1.base/1-1-install-download/>1.1 安装与下载</a></li><li><a href=/1.base/1-2-hello-world/>1.2 跑起来</a></li><li><a href=/1.base/1-3-go-mod/>1.3 go mod最佳实践</a></li><li><a href=/1.base/1-4-variables/>1.4 变量与常量</a></li><li><a href=/1.base/1-5-switch%E5%92%8Ctypeswitch/>1.5 switch和type switch</a></li><li><a href=/1.base/1-6-for-range/>1.6 循环</a></li><li><a href=/1.base/1-7-range%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/>1.7 range深度解析</a></li></ul></li><li><strong>第二章、函数和容器</strong><ul><li><a href=/2.func-containers/2-1-func/>2.1 函数简单使用和基本知识解析</a></li><li><a href=/2.func-containers/2-2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/>2.2 匿名函数和闭包</a></li><li><a href=/2.func-containers/2-3-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/>2.3 可变参数</a></li><li><a href=/2.func-containers/2-4-map/>2.4 集合（map）</a></li><li><a href=/2.func-containers/2-5-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/>2.5 数组和切片</a></li></ul></li><li><strong>第三章、语法进阶</strong><ul><li><a href=/3.grammar-advancement/3-1-point/>3.1 指针讨论</a></li><li><a href=/3.grammar-advancement/3-2-struct/>3.2 结构体</a></li><li><a href=/3.grammar-advancement/3-3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/>3.3 接口与多态</a></li><li><a href=/3.grammar-advancement/3-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/>3.4 异常处理</a></li></ul></li><li><strong>第四章、并发和并行</strong><ul><li><a href=/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/>4.1 并发特性</a></li><li><a href=/4.concurrent/4-2-goroutine-wait/>4.2 并发等待</a></li><li><a href=/4.concurrent/4-3-channel/>4.3 channel</a></li><li><a href=/4.concurrent/4-4-deadlock/>4.4 deadlock</a></li><li><a href=/4.concurrent/4-5-select/>4.5 select</a></li><li>-并发安全</li><li>-协程池</li><li>-消费者生产者框架</li><li>-GMP调度原理</li><li>-服务器监控实战</li></ul></li><li><strong>第x章、反射</strong></li><li><strong>第x章、调试与测试</strong><ul><li>-单元测试</li><li>-基准测试</li><li>-mock</li><li>-自动化测试</li><li>-调试</li></ul></li><li><strong>第x章、标准库</strong><ul><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E4%BB%A3%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/>Go代码基本标准规范</a></li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/>文件操作</a></li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8Fsort%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/>排序</a></li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/flag%E5%8C%85%E8%AF%BB%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE/>命令行操作</a></li><li>-时间处理</li><li>-字符串处理</li><li>-json库</li><li>-http库</li><li>跨平台编译</li><li>模板</li><li>在线工具系统实战</li></ul></li><li><strong>第x章、性能调优</strong><ul><li>-cpu调度</li><li>-内存管理</li><li>-垃圾回收</li><li>-PProf</li><li>-逃逸分析</li><li>-链路追踪</li></ul></li><li><strong>第x章、优秀开源组件</strong><ul><li>-日志</li><li>-配置管理</li><li>-接口文档</li><li>-错误码控制</li><li>-mysql</li><li>-redis</li><li>-mongo</li><li>rabbitmq</li><li>kafka</li><li>-为开源项目贡献代码</li></ul></li><li><strong>第x章、web开发实战</strong><ul><li>-HTTP</li><li>-GRPC</li><li>-Protobuf</li><li>-gin</li></ul></li><li><strong>第x章、爬虫实战</strong></li><li><strong>第x章、在线教育系统实战</strong><ul><li>-在线考试系统实战</li><li>-知识付费系统实战</li><li>-在线课堂系统实战</li></ul></li><li><strong>第x章、微服务</strong><ul><li>熔断与限流</li></ul></li><li><strong>第x章、分布式系统</strong><ul><li>-分布式ID生成器</li><li>-分布式锁</li><li>-分布式一致性算法</li><li>-分布式定时任务</li><li>-分布式计算</li></ul></li><li><strong>第x章、Go语言工程化实战</strong><ul><li>构建约束</li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/golang%E6%89%93%E9%95%9C%E5%83%8Fdockerfile%E7%9A%84%E5%86%99%E6%B3%95/>Go与Dockerfile</a></li></ul></li><li><strong>第x章、Go语言运维实战</strong></li><li><strong>第x章、Go语言监控实战</strong><ul><li>-自监控</li></ul></li><li><strong>第x章、kubernetes开发实战</strong></li><li><strong>第x章、服务治理</strong></li><li><strong>番外1、拓展应用</strong><ul><li><a href=/tools/readme/>小工具</a></li></ul></li><li><strong>番外2、陷阱与缺陷</strong><ul><li><a href=/impossible/range/readme/>range的第二个值实际上是值拷贝</a></li><li><a href=/impossible/%E6%96%B0%E6%89%8B%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>新手常犯的错误</a></li><li><a href=/impossible/%E5%88%9D%E5%AD%A6%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/ class=active>初学者常犯的错误</a></li><li><a href=/impossible/%E8%BF%9B%E9%98%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>进阶常犯的错误</a></li></ul></li><li><strong>第x章、GO语言版本分析</strong></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>初学者常犯的错误</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#索引运算符和字符串>索引运算符和字符串</a></li><li><a href=#使用-for-range子句遍历-map>使用 「for range」子句遍历 Map</a></li><li><a href=#增量和减量>增量和减量</a></li><li><a href=#按位-not-运算符>按位 NOT 运算符</a></li><li><a href=#运算符优先级差异>运算符优先级差异</a></li><li><a href=#未导出的结构字段不进行编码>未导出的结构字段不进行编码</a></li><li><a href=#应用退出与活动的-goroutines>应用退出与活动的 Goroutines</a></li><li><a href=#nil-使用-nil-通道>&ldquo;nil&rdquo; 使用 “nil” 通道</a></li><li><a href=#方法中的接受者不能修改原始值>方法中的接受者不能修改原始值</a></li></ul></nav></aside></header><article class=markdown><h1 id=初学者常犯的错误>初学者常犯的错误
<a class=anchor href=#%e5%88%9d%e5%ad%a6%e8%80%85%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af>#</a></h1><blockquote><p>引用：
<a href=https://learnku.com/go/wikis/49781>Go 经典译文：50 个 Go 新手易犯的错误（2020版）</a></p></blockquote><h2 id=索引运算符和字符串>索引运算符和字符串
<a class=anchor href=#%e7%b4%a2%e5%bc%95%e8%bf%90%e7%ae%97%e7%ac%a6%e5%92%8c%e5%ad%97%e7%ac%a6%e4%b8%b2>#</a></h2><p>字符串上的 index 方法 （运算符） 返回一个字节值，而不是一个字符类型（就像在其他语言中一样）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;text&#34;</span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#75715e>//print 116
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%T&#34;</span>,<span style=color:#a6e22e>x</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#75715e>//prints uint8
</span><span style=color:#75715e></span>}
</code></pre></div><p>如果需要访问特定字符串 “characters”（unicode 代码点 / 运行符），请使用 <code>for range</code> 语句。官方的 “unicode/utf8” 包和基础的 utf8string 包 （golang.org/x/exp/utf8string） 也很有用。utf8string 包有一个方便的 <code>At()</code> 方法，将字符串转换为切片也是一种选择。</p><h2 id=使用-for-range子句遍历-map>使用 「for range」子句遍历 Map
<a class=anchor href=#%e4%bd%bf%e7%94%a8-for-range%e5%ad%90%e5%8f%a5%e9%81%8d%e5%8e%86-map>#</a></h2><ul><li>level：初学者</li></ul><p>如果你希望 Map 每项数据按照顺序排列 （例如，按键值顺序），这是不可能的，每次 Map 迭代会输出不一样的结果。GO 运行时可能会随机分配迭代顺序，因此你可能会得到几次相同的 Map 迭代结果也不用惊讶。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>{<span style=color:#e6db74>&#34;one&#34;</span>:<span style=color:#ae81ff>1</span>,<span style=color:#e6db74>&#34;two&#34;</span>:<span style=color:#ae81ff>2</span>,<span style=color:#e6db74>&#34;three&#34;</span>:<span style=color:#ae81ff>3</span>,<span style=color:#e6db74>&#34;four&#34;</span>:<span style=color:#ae81ff>4</span>}
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>,<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>m</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>k</span>,<span style=color:#a6e22e>v</span>)
    }
}
</code></pre></div><p>而且，如果你使用 Go Playground （
<a href=https://play.golang.org/>play.golang.org/</a>） 运行这段代码，将始终得到相同的迭代结果，因为除非进行更改代码，否则它不会重新编译代码。</p><h2 id=增量和减量>增量和减量
<a class=anchor href=#%e5%a2%9e%e9%87%8f%e5%92%8c%e5%87%8f%e9%87%8f>#</a></h2><ul><li>级别：初学者</li></ul><p>许多语言都有递增和递减运算符。与其他语言不同，Go 不支持操作的前缀版本。你也不能在表达式中使用这两个运算符。</p><p>失败：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(){
    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>}
    <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#f92672>++</span><span style=color:#a6e22e>i</span> <span style=color:#75715e>//错误
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>data</span> [<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>])<span style=color:#75715e>//错误
</span><span style=color:#75715e></span>}
</code></pre></div><p>编译错误：</p><blockquote><p>/tmp/sandbox101231828/main.go:8：语法错误：意外的 ++ /tmp/sandbox101231828/main.go:9：语法错误：意外的 ++，期望：</p></blockquote><p>作品：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(){
    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>}
    <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>i</span>])
}
</code></pre></div><h2 id=按位-not-运算符>按位 NOT 运算符
<a class=anchor href=#%e6%8c%89%e4%bd%8d-not-%e8%bf%90%e7%ae%97%e7%ac%a6>#</a></h2><ul><li>级别：初学者</li></ul><p>许多语言都使用<code>〜</code>作为一元 NOT 运算符 （也称为按位补码），但是 Go 为此重用了 XOR 运算符 （<code>^</code>）。</p><p>失败：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(){
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#960050;background-color:#1e0010>〜</span><span style=color:#ae81ff>2</span>)<span style=color:#75715e>//错误
</span><span style=color:#75715e></span>}
</code></pre></div><p>编译错误：</p><blockquote><p>/tmp/sandbox965529189/main.go:6：按位补码运算符是 ^</p></blockquote><p>作品：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(){
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> <span style=color:#66d9ef>uint8</span> = <span style=color:#ae81ff>2</span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#960050;background-color:#1e0010>“％</span><span style=color:#ae81ff>08</span><span style=color:#a6e22e>b</span> <span style=color:#960050;background-color:#1e0010>\</span> <span style=color:#a6e22e>n</span><span style=color:#960050;background-color:#1e0010>”，</span>^ <span style=color:#a6e22e>d</span>)
}
</code></pre></div><p>Go 仍然使用 <code>^</code> 作为 XOR 运算符，这可能会使某些人感到困惑。</p><p>如果你愿意，你可以用二进制的 XOR 操作 （例如，' NOT 0x02 &lsquo;） 来表示一个单目的 NOT 操作 （例如，&rsquo; 0x02 XOR 0xff &lsquo;）。这可以解释为什么 <code>^</code> 被重用于表示一元 NOT 操作。</p><p>Go 还具有一个特殊的 &lsquo;AND NOT&rsquo; 按位运算符 （<code>&^</code>），这增加了 NOT 运算符的困惑。看起来像一个特性 / 黑客，不需要括号就可以支持 <code>A AND (NOT B)</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>uint8</span> = <span style=color:#ae81ff>0x82</span>
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>uint8</span> = <span style=color:#ae81ff>0x02</span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%08b [A]\n&#34;</span>,<span style=color:#a6e22e>a</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%08b [B]\n&#34;</span>,<span style=color:#a6e22e>b</span>)

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%08b (NOT B)\n&#34;</span>,^<span style=color:#a6e22e>b</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%08b ^ %08b = %08b [B XOR 0xff]\n&#34;</span>,<span style=color:#a6e22e>b</span>,<span style=color:#ae81ff>0xff</span>,<span style=color:#a6e22e>b</span> ^ <span style=color:#ae81ff>0xff</span>)

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%08b ^ %08b = %08b [A XOR B]\n&#34;</span>,<span style=color:#a6e22e>a</span>,<span style=color:#a6e22e>b</span>,<span style=color:#a6e22e>a</span> ^ <span style=color:#a6e22e>b</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%08b &amp; %08b = %08b [A AND B]\n&#34;</span>,<span style=color:#a6e22e>a</span>,<span style=color:#a6e22e>b</span>,<span style=color:#a6e22e>a</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>b</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%08b &amp;^%08b = %08b [A &#39;AND NOT&#39; B]\n&#34;</span>,<span style=color:#a6e22e>a</span>,<span style=color:#a6e22e>b</span>,<span style=color:#a6e22e>a</span> <span style=color:#f92672>&amp;^</span> <span style=color:#a6e22e>b</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&#34;</span>,<span style=color:#a6e22e>a</span>,<span style=color:#a6e22e>b</span>,<span style=color:#a6e22e>a</span> <span style=color:#f92672>&amp;</span> (^<span style=color:#a6e22e>b</span>))
}
</code></pre></div><h2 id=运算符优先级差异>运算符优先级差异
<a class=anchor href=#%e8%bf%90%e7%ae%97%e7%ac%a6%e4%bc%98%e5%85%88%e7%ba%a7%e5%b7%ae%e5%bc%82>#</a></h2><ul><li>级别：初学者</li></ul><p>除了「位清除」运算符 （<code>＆^</code>） 之外，Go 还有许多其他语言共享的一组标准运算符。但是，运算符优先级并不总是相同。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;0x2 &amp; 0x2 + 0x4 -&gt; %#x\n&#34;</span>,<span style=color:#ae81ff>0x2</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x4</span>)
    <span style=color:#75715e>//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6
</span><span style=color:#75715e></span>    <span style=color:#75715e>//Go:    (0x2 &amp; 0x2) + 0x4
</span><span style=color:#75715e></span>    <span style=color:#75715e>//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n&#34;</span>,<span style=color:#ae81ff>0x2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x2</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>0x1</span>)
    <span style=color:#75715e>//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6
</span><span style=color:#75715e></span>    <span style=color:#75715e>//Go:     0x2 + (0x2 &lt;&lt; 0x1)
</span><span style=color:#75715e></span>    <span style=color:#75715e>//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;0xf | 0x2 ^ 0x2 -&gt; %#x\n&#34;</span>,<span style=color:#ae81ff>0xf</span> | <span style=color:#ae81ff>0x2</span> ^ <span style=color:#ae81ff>0x2</span>)
    <span style=color:#75715e>//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd
</span><span style=color:#75715e></span>    <span style=color:#75715e>//Go:    (0xf | 0x2) ^ 0x2
</span><span style=color:#75715e></span>    <span style=color:#75715e>//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=未导出的结构字段不进行编码>未导出的结构字段不进行编码
<a class=anchor href=#%e6%9c%aa%e5%af%bc%e5%87%ba%e7%9a%84%e7%bb%93%e6%9e%84%e5%ad%97%e6%ae%b5%e4%b8%8d%e8%bf%9b%e8%a1%8c%e7%bc%96%e7%a0%81>#</a></h2><ul><li>级别：初学者</li></ul><p>以小写字母开头的 struct 字段将不被编码 （json、xml、gob 等），因此，当你解码结构时，在这些未导出的字段中最终将得到零值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;encoding/json&#34;</span>
)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MyData</span> <span style=color:#66d9ef>struct</span> {  
    <span style=color:#a6e22e>One</span> <span style=color:#66d9ef>int</span>
    <span style=color:#a6e22e>two</span> <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>in</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>MyData</span>{<span style=color:#ae81ff>1</span>,<span style=color:#e6db74>&#34;two&#34;</span>}
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%#v\n&#34;</span>,<span style=color:#a6e22e>in</span>) <span style=color:#75715e>//prints main.MyData{One:1, two:&#34;two&#34;}
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>encoded</span>,<span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>in</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(string(<span style=color:#a6e22e>encoded</span>)) <span style=color:#75715e>//prints {&#34;One&#34;:1}
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>out</span> <span style=color:#a6e22e>MyData</span>
    <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>encoded</span>,<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>out</span>)

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%#v\n&#34;</span>,<span style=color:#a6e22e>out</span>) <span style=color:#75715e>//prints main.MyData{One:1, two:&#34;&#34;}
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=应用退出与活动的-goroutines>应用退出与活动的 Goroutines
<a class=anchor href=#%e5%ba%94%e7%94%a8%e9%80%80%e5%87%ba%e4%b8%8e%e6%b4%bb%e5%8a%a8%e7%9a%84-goroutines>#</a></h2><ul><li>级别：初学者</li></ul><p>应用程序不会等待你的所有 goroutine 完成。对于一般的初学者来说，这是一个常见的错误。每个人都从某个地方开始，所以在犯菜鸟错误时不要觉得丢脸</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>workerCount</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span>

    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>workerCount</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>doit</span>(<span style=color:#a6e22e>i</span>)
    }
    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;all done!&#34;</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>doit</span>(<span style=color:#a6e22e>workerId</span> <span style=color:#66d9ef>int</span>) {  
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%v] is running\n&#34;</span>,<span style=color:#a6e22e>workerId</span>)
    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%v] is done\n&#34;</span>,<span style=color:#a6e22e>workerId</span>)
}
</code></pre></div><p>你会看到的：</p><blockquote><p>[0] 正在运行<br>[1] 正在运行<br>全部完成！</p></blockquote><p>最常见的解决方案之一是使用 “WaitGroup” 变量。它将允许主 goroutine 等待直到所有工作程序 goroutine 完成。如果你的应用程序具有长时间运行的消息处理循环，则你还需要一种方法向那些 goroutine 发出退出信号的信号。你可以向每个工作人员发送 “杀死” 消息。另一个选择是关闭所有工作人员正在接收的渠道。这是一次发出所有 goroutine 信号的简单方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;sync&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
    <span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{})
    <span style=color:#a6e22e>workerCount</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span>

    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>workerCount</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
        <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>doit</span>(<span style=color:#a6e22e>i</span>,<span style=color:#a6e22e>done</span>,<span style=color:#a6e22e>wg</span>)
    }

    close(<span style=color:#a6e22e>done</span>)
    <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;all done!&#34;</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>doit</span>(<span style=color:#a6e22e>workerId</span> <span style=color:#66d9ef>int</span>,<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{},<span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>) {  
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%v] is running\n&#34;</span>,<span style=color:#a6e22e>workerId</span>)
    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
    <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>done</span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%v] is done\n&#34;</span>,<span style=color:#a6e22e>workerId</span>)
}
</code></pre></div><p>如果你运行此应用，将会看到:</p><blockquote><p>[0] is running<br>[0] is done<br>[1] is running<br>[1] is done</p></blockquote><p>看起来 worker 在主 goroutine 退出之前已经完成。这太棒了！但是 1，你还会看到这样的情况：</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!</p></blockquote><p>这不太好 发生了什么？为什么会出现死锁？当 worker 离开时，它们执行了 <code>wg.Done()</code>。应用程序应该是可以工作的。</p><p>发生死锁是因为每个 Worker 都会获得原始「WaitGroup」变量的副本。当工人执行 <code>wg.Done()</code> 时，它不会影响主 goroutine 中 的「WaitGroup」变量。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;sync&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
    <span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{})
    <span style=color:#a6e22e>wq</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>interface</span>{})
    <span style=color:#a6e22e>workerCount</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span>

    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>workerCount</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
        <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>doit</span>(<span style=color:#a6e22e>i</span>,<span style=color:#a6e22e>wq</span>,<span style=color:#a6e22e>done</span>,<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>)
    }

    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>workerCount</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#a6e22e>wq</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>
    }

    close(<span style=color:#a6e22e>done</span>)
    <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;all done!&#34;</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>doit</span>(<span style=color:#a6e22e>workerId</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>wq</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>interface</span>{},<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{},<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>) {  
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%v] is running\n&#34;</span>,<span style=color:#a6e22e>workerId</span>)
    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
    <span style=color:#66d9ef>for</span> {
        <span style=color:#66d9ef>select</span> {
        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>wq</span>:
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%v] m =&gt; %v\n&#34;</span>,<span style=color:#a6e22e>workerId</span>,<span style=color:#a6e22e>m</span>)
        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>done</span>:
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%v] is done\n&#34;</span>,<span style=color:#a6e22e>workerId</span>)
            <span style=color:#66d9ef>return</span>
        }
    }
}
</code></pre></div><p>现在它可以按预期工作了</p><h2 id=nil-使用-nil-通道>&ldquo;nil&rdquo; 使用 “nil” 通道
<a class=anchor href=#nil-%e4%bd%bf%e7%94%a8-nil-%e9%80%9a%e9%81%93>#</a></h2><p>Send and receive operations on a <code>nil</code> channel block forver. It&rsquo;s a well documented behavior, but it can be a surprise for new Go developers.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ch</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>3</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>idx</span> <span style=color:#66d9ef>int</span>) {
            <span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> (<span style=color:#a6e22e>idx</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
        }(<span style=color:#a6e22e>i</span>)
    }

    <span style=color:#75715e>//get first result
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;result:&#34;</span>,<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>)
    <span style=color:#75715e>//do other work
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
}
</code></pre></div><p>如果运行你的代码，你会看到这样的报错：<br><code>fatal error: all goroutines are asleep - deadlock!</code></p><p>出现这样的错误是因为你在 <code>select</code> 语句中 <code>case</code> 块中动态启用和禁用了管道。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>  
<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;time&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>inch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
    <span style=color:#a6e22e>outch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)

    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>in</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span> = <span style=color:#a6e22e>inch</span>
        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>out</span> <span style=color:#66d9ef>chan</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>int</span>
        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int</span>
        <span style=color:#66d9ef>for</span> {
            <span style=color:#66d9ef>select</span> {
            <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>out</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>val</span>:
                <span style=color:#a6e22e>out</span> = <span style=color:#66d9ef>nil</span>
                <span style=color:#a6e22e>in</span> = <span style=color:#a6e22e>inch</span>
            <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>val</span> = <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>in</span>:
                <span style=color:#a6e22e>out</span> = <span style=color:#a6e22e>outch</span>
                <span style=color:#a6e22e>in</span> = <span style=color:#66d9ef>nil</span>
            }
        }
    }()

    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>outch</span> {
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;result:&#34;</span>,<span style=color:#a6e22e>r</span>)
        }
    }()

    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>0</span>)
    <span style=color:#a6e22e>inch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>1</span>
    <span style=color:#a6e22e>inch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>2</span>
    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
}
</code></pre></div><h2 id=方法中的接受者不能修改原始值>方法中的接受者不能修改原始值
<a class=anchor href=#%e6%96%b9%e6%b3%95%e4%b8%ad%e7%9a%84%e6%8e%a5%e5%8f%97%e8%80%85%e4%b8%8d%e8%83%bd%e4%bf%ae%e6%94%b9%e5%8e%9f%e5%a7%8b%e5%80%bc>#</a></h2><ul><li>级别：初学者</li></ul><p>方法接收者就像常规函数参数一样。如果声明为值，那么你的函数 / 方法将获得接收器参数的副本。这意味着对接收者进行更改不会影响原始值，除非你的接收者是映射或切片变量，并且你要更新集合中的项，或者你要在接收者中更新的字段是指针。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>data</span> <span style=color:#66d9ef>struct</span> {  
    <span style=color:#a6e22e>num</span> <span style=color:#66d9ef>int</span>
    <span style=color:#a6e22e>key</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>string</span>
    <span style=color:#a6e22e>items</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>bool</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>this</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>data</span>) <span style=color:#a6e22e>pmethod</span>() {  
    <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>num</span> = <span style=color:#ae81ff>7</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>this</span> <span style=color:#a6e22e>data</span>) <span style=color:#a6e22e>vmethod</span>() {  
    <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>num</span> = <span style=color:#ae81ff>8</span>
    <span style=color:#f92672>*</span><span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>key</span> = <span style=color:#e6db74>&#34;v.key&#34;</span>
    <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>items</span>[<span style=color:#e6db74>&#34;vmethod&#34;</span>] = <span style=color:#66d9ef>true</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;key.1&#34;</span>
    <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>data</span>{<span style=color:#ae81ff>1</span>,<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>key</span>,make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>bool</span>)}

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;num=%v key=%v items=%v\n&#34;</span>,<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>num</span>,<span style=color:#f92672>*</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>key</span>,<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>items</span>)
    <span style=color:#75715e>//prints num=1 key=key.1 items=map[]
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>pmethod</span>()
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;num=%v key=%v items=%v\n&#34;</span>,<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>num</span>,<span style=color:#f92672>*</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>key</span>,<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>items</span>) 
    <span style=color:#75715e>//prints num=7 key=key.1 items=map[]
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>vmethod</span>()
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;num=%v key=%v items=%v\n&#34;</span>,<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>num</span>,<span style=color:#f92672>*</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>key</span>,<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>items</span>)
    <span style=color:#75715e>//prints num=7 key=v.key items=map[vmethod:true]
</span><span style=color:#75715e></span>}
</code></pre></div></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=minibear2333/blog-comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/golang-minibear2333/golang/edit/master/./impossible/%e5%88%9d%e5%ad%a6%e8%80%85%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#索引运算符和字符串>索引运算符和字符串</a></li><li><a href=#使用-for-range子句遍历-map>使用 「for range」子句遍历 Map</a></li><li><a href=#增量和减量>增量和减量</a></li><li><a href=#按位-not-运算符>按位 NOT 运算符</a></li><li><a href=#运算符优先级差异>运算符优先级差异</a></li><li><a href=#未导出的结构字段不进行编码>未导出的结构字段不进行编码</a></li><li><a href=#应用退出与活动的-goroutines>应用退出与活动的 Goroutines</a></li><li><a href=#nil-使用-nil-通道>&ldquo;nil&rdquo; 使用 “nil” 通道</a></li><li><a href=#方法中的接受者不能修改原始值>方法中的接受者不能修改原始值</a></li></ul></nav></div></aside></main></body></html>