<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="简介 #  Goroutine 是 Golang 中非常有用的功能，有时候 goroutine 没执行完函数就返回了，如果希望等待当前的 goroutine 执行完成再接着往下执行，该怎么办？
package main import ( &#34;time&#34; &#34;fmt&#34; ) func say(s string) { for i := 0; i &lt; 3; i&#43;&#43; { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&#34;hello world&#34;) fmt.Println(&#34;over!&#34;) } 输出 over！ , 主线程没有等待
唯一好方案 #  Golang 官方在 sync 包中提供了 WaitGroup 类型来解决这个问题。其文档描述如下：
 A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="" />
<meta property="og:description" content="简介 #  Goroutine 是 Golang 中非常有用的功能，有时候 goroutine 没执行完函数就返回了，如果希望等待当前的 goroutine 执行完成再接着往下执行，该怎么办？
package main import ( &#34;time&#34; &#34;fmt&#34; ) func say(s string) { for i := 0; i &lt; 3; i&#43;&#43; { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&#34;hello world&#34;) fmt.Println(&#34;over!&#34;) } 输出 over！ , 主线程没有等待
唯一好方案 #  Golang 官方在 sync 包中提供了 WaitGroup 类型来解决这个问题。其文档描述如下：
 A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://golang.coding3min.com/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E7%AD%89%E5%BE%85goroutine%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1_%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8goroutine/" /><meta property="article:section" content="番外.常用操作" />



<title>等待goroutine完成任务 循环中使用goroutine | go语言精进之路</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css" integrity="sha256-lYzqeCdiHW&#43;8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.f5653653434fac73aa8d1cd046b8b2fa2ce8221a20e086faabf08e2b1464925a.js" integrity="sha256-9WU2U0NPrHOqjRzQRriy&#43;izoIhog4Ib6q/COKxRkklo=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
<input type="checkbox" class="hidden toggle" id="menu-control" />
<input type="checkbox" class="hidden toggle" id="toc-control" />
<main class="container flex">
  <aside class="book-menu">
    <div class="book-menu-content">
      
<nav>
<h2 class="book-brand">
  <a href="/"><img src="/logo.png" alt="Logo" /><span>go语言精进之路</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  <ul>
<li>
  <a href="https://coding3min.com">机智的程序员小熊</a></li>
<li>
  <a href="https://github.com/minibear2333/">GitHub</a></li>
<li>
  <a href="/qrcode/">微信公众号</a></li>
<li><strong>帮助与提示</strong>
<ul>
<li>
  <a href="/howtocontribute/">0.0 如何参与贡献</a></li>
<li>
  <a href="/books-share/">0.1 书籍推荐</a></li>
</ul>
</li>
<li><strong>第一章、Go基础</strong>
<ul>
<li>
  <a href="/1.base/1-1-install-download/">1.1 安装与下载</a></li>
<li>
  <a href="/1.base/1-2-hello-world/">1.2 跑起来</a></li>
<li>
  <a href="/1.base/1-3-go-mod/">1.3 go mod最佳实践</a></li>
<li>
  <a href="/1.base/1-4-variables/">1.4 变量与常量</a></li>
<li>
  <a href="/1.base/1-5-switch%E5%92%8Ctypeswitch/">1.5 switch和type switch</a></li>
<li>
  <a href="/1.base/1-6-for-range/">1.6 循环</a></li>
<li>
  <a href="/1.base/1-7-range%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">1.7 range深度解析</a></li>
</ul>
</li>
<li><strong>第二章、函数和容器</strong>
<ul>
<li>
  <a href="/2.func-containers/2-1-func/">2.1 函数简单使用和基本知识解析</a></li>
<li>
  <a href="/2.func-containers/2-2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/">2.2 匿名函数和闭包</a></li>
<li>
  <a href="/2.func-containers/2-3-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/">2.3 可变参数</a></li>
<li>
  <a href="/2.func-containers/2-4-map/">2.4 集合（map）</a></li>
<li>
  <a href="/2.func-containers/2-5-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">2.5 数组和切片</a></li>
</ul>
</li>
<li><strong>第三章、语法进阶</strong>
<ul>
<li>
  <a href="/3.grammar-advancement/3-1-point/">3.1 指针讨论</a></li>
<li>
  <a href="/3.grammar-advancement/3-2-struct/">3.2 结构体</a></li>
<li>
  <a href="/3.grammar-advancement/3-3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/">3.3 接口与多态</a></li>
<li>
  <a href="/3.grammar-advancement/3-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">3.4 异常处理</a></li>
</ul>
</li>
<li><strong>第四章、并发和并行</strong>
<ul>
<li>
  <a href="/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/">4.1 并发特性</a></li>
<li>
  <a href="/4.concurrent/channel/">4.2 channel</a></li>
<li>
  <a href="/4.concurrent/select/">4.3 select</a></li>
<li>
  <a href="/4.concurrent/timeout/">4.4 设置超时</a></li>
</ul>
</li>
<li><strong>时间处理与定时任务</strong>
<ul>
<li>
  <a href="/a.timer/reset/reset-time/">设置可热更新的定时器</a></li>
</ul>
</li>
<li><strong>常用操作</strong>
<ul>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/">1.1 Go文件操作大全</a></li>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E4%BB%A3%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/">1.2 Go代码基本标准规范</a></li>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8Fsort%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/">1.3 切片排序sort包的使用</a></li>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/golang%E6%89%93%E9%95%9C%E5%83%8Fdockerfile%E7%9A%84%E5%86%99%E6%B3%95/">1.4 Go与Dockerfile</a></li>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E7%AD%89%E5%BE%85goroutine%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1_%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8goroutine/"class=active>1.5 goroutine等待</a></li>
<li>
  <a href="/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/flag%E5%8C%85%E8%AF%BB%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE/">1.6 命令行操作</a></li>
<li>
  <a href="/tools/readme/">2. 小工具</a></li>
</ul>
</li>
<li><strong>go陷阱与缺陷</strong>
<ul>
<li>
  <a href="/impossible/range/readme/">range的第二个值实际上是值拷贝</a></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
    </div>
  </aside>

  <div class="book-page">
    <header class="book-header">
      

 
    </header>

    
    
<main class="site-main section-inner thin animated fadeIn faster">
  <h1></h1>
  <div class="content">
    <h2 id="简介">
  简介
  <a class="anchor" href="#%e7%ae%80%e4%bb%8b">#</a>
</h2>
<p><code>Goroutine</code> 是 <code>Golang</code> 中非常有用的功能，有时候 <code>goroutine</code> 没执行完函数就返回了，如果希望等待当前的 <code>goroutine</code> 执行完成再接着往下执行，该怎么办？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;time&#34;</span>
    <span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">100</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">say</span>(<span style="color:#e6db74">&#34;hello world&#34;</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;over!&#34;</span>)
}
</code></pre></div><p>输出 <code>over！</code> , 主线程没有等待</p>
<h2 id="唯一好方案">
  唯一好方案
  <a class="anchor" href="#%e5%94%af%e4%b8%80%e5%a5%bd%e6%96%b9%e6%a1%88">#</a>
</h2>
<p>Golang 官方在 sync 包中提供了 WaitGroup 类型来解决这个问题。其文档描述如下：</p>
<blockquote>
<p>A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.</p>
</blockquote>
<p>大意为： <code>WaitGroup</code> 用来等待单个或多个 <code>goroutines</code> 执行结束。在主逻辑中使用 <code>WaitGroup</code> 的 <code>Add</code> 方法设置需要等待的 <code>goroutines</code> 的数量。在每个 goroutine 执行的函数中，需要调用 <code>WaitGroup</code> 的 <code>Done</code> 方法。最后在主逻辑中调用 <code>WaitGroup</code> 的 <code>Wait</code> 方法进行阻塞等待，直到所有 <code>goroutine</code> 执行完成。
使用方法可以总结为下面几点：</p>
<ul>
<li>创建一个 <code>WaitGroup</code> 实例，比如名称为：wg</li>
<li>调用 <code>wg.Add(n)</code> ，其中 n 是等待的 <code>goroutine</code> 的数量</li>
<li>在每个 <code>goroutine</code> 运行的函数中执行 <code>defer wg.Done()</code></li>
<li>调用 <code>wg.Wait()</code> 阻塞主逻辑</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;time&#34;</span>
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">say2</span>(<span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
    <span style="color:#a6e22e">say2</span>(<span style="color:#e6db74">&#34;world&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;over!&#34;</span>)
    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say2</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">waitGroup</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">waitGroup</span>.<span style="color:#a6e22e">Done</span>()

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
    }
}
</code></pre></div><p>简短的例子，注意循环传入的变量用中间变量替代，防止闭包 <code>bug</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(len(<span style="color:#a6e22e">sList</span>))
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">sList</span> {
		<span style="color:#a6e22e">tmpD</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">d</span>
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">waitGroup</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
            <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">waitGroup</span>.<span style="color:#a6e22e">Done</span>()
            <span style="color:#75715e">// to do something
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// use tmpD 
</span><span style="color:#75715e"></span>            }
		}(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</code></pre></div><h2 id="引用">
  引用
  <a class="anchor" href="#%e5%bc%95%e7%94%a8">#</a>
</h2>
<p>
  <a href="https://www.cnblogs.com/sparkdev/p/10917536.html">Golang 入门 : 等待 goroutine 完成任务</a></p>

  </div>
  <div class="book-footer justify-between"></div>
  <hr style="height: 1px;
    background: var(--gray-200);">
  <br>
  <p>本图书由<a href="https://github.com/minibear2333">小熊</a>©2021 版权所有，<a href="https://golang.coding3min.com/">所有文章</a>采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p>
  <div id="comments" class="thin">
    <script src="https://utteranc.es/client.js"
        repo="minibear2333/blog-comment"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
  </div>
</main>
 
    

    <footer class="book-footer">
      

 
      
    </footer>

    

 

    <label for="menu-control" class="hidden book-menu-overlay"></label>
  </div>

  
  <aside class="book-toc">
    <div class="book-toc-content">
      

<nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#唯一好方案">唯一好方案</a></li>
    <li><a href="#引用">引用</a></li>
  </ul>
</nav>


 
    </div>
  </aside>
  
</main>


</body>
</html>











