<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>4.concurrents on Go语言精进之路</title><link>https://golang.coding3min.com/4.concurrent/</link><description>Recent content in 4.concurrents on Go语言精进之路</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://golang.coding3min.com/4.concurrent/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://golang.coding3min.com/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/</guid><description>4.1 go 语言中的并发特性 # 本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/4.concurrent/4.1-goroutine/
以前我们写并发的程序一般是用多线程来实现，自己维护一个线程池，在恰当的时候创建、销毁、分配资源。
go 在并发方面为我们提供了一个语言级别的支持， goroutine 和 channel 相互配合，这决定了他的先天优势。
goroutine 也就是go协程，概念类似于线程， Go 程序运行时会自动调度和管理，系统能智能地将 goroutine 中的任务合理地分配给 CPU , 让这些任务尽量并发运作。
这里说并发其实是不严谨的，只不过我们习惯了说并发，延展阅读见 goroutine是并行还是并发？
4.1.1 他和线程对比 # 从使用上讲
比线程更轻量级，可以创建十万、百万不用担心资源问题。 和 channel 搭配使用，实现高并发， goroutine 之间传输数据更方便。 如果访问同一个数据块，要小心数据竞态问题、共享锁还是互斥锁的选择问题、并发操作的数据同步问题（后面会说） 从其实现上讲
从资源上讲，线程的栈内存大小一般是固定的一般为 2MB ，虽然这个数值可以设置，但是 太大了浪费，太小了容易不够用, 而 goroutine 栈内存是可变的，初始一般为 2KB ，随着需求可以扩大达到 1GB。 所以 goroutine 十分的轻量级，且能满足不同的需求。 从调度上讲，线程的调度由 OS 的内核完成；线程的切换需要 CPU 寄存器 和 内存的数据交换 ，从而切换不同的线程上下文。 其触发方式为 CPU时钟 , 而 goroutine 的调度则比较轻量级，由自身的调度器完成。 协程同线程的关系，有些类似于 线程同进程的关系。 4.</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-2-goroutine-wait/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-2-goroutine-wait/</guid><description>4.2 并发等待 # 本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/4.concurrent/4.2-goroutine-wait/
4.2.1 简介 # goroutine 是 Golang 中非常有用的功能，有时候 goroutine 没执行完函数就返回了，如果希望等待当前的 goroutine 执行完成再接着往下执行，该怎么办？
func say(s string) { for i := 0; i &amp;lt; 3; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&amp;#34;hello world&amp;#34;) fmt.Println(&amp;#34;over!&amp;#34;) } 输出 over！ , 主线程没有等待
4.2.2 使用 Sleep 等待 # func main() { go say(&amp;#34;hello world&amp;#34;) time.Sleep(time.Second*1) fmt.Println(&amp;#34;over!&amp;#34;) } 运行修改后的程序，结果如下：
hello world hello world hello world over!</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-3-channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-3-channel/</guid><description>4.3 channel # 到这里你正在接触最核心和重要的知识！认真学习的你很棒！
本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/4.concurrent/4.3-channel/
4.3.1 什么是 channel # Go 是一门从语言级别就支持并发的编程语言， 它有一个设计哲学很特别 不要通过共享内存来通信，而应通过通信来共享内存 ，听起来是有一点绕。
在传统语言中并发使用全局变量来进行不同线程之间的数据共享，这种方式就是使用共享内存的方式进行通信。而 Go 会在协程和协程之间打一个隧道，通过这个隧道来传输数据（发送和接收）。
打个比方，我们平时肯定没少接触过队列，队列的特点是先进先出，多方生产插入，多方消费接收。这个队列/隧道就是channel。
channel 是 goroutine 之间互相通讯的东西，goroutine 之间用来发消息和接收消息。其实，就是在做 goroutine 之间的内存共享。
我们来看看具体是什么使用的。
4.3.2 声明与初始化 # channel是类型相关的，也就是说一个 channel 只能传递一种类型的值，这个类型需要在 channel 声明时指定。
channel 的一般声明形式：
var chanName chan 类型 与普通变量的声明不同的是在类型前面加了 channel 关键字，类型 则指定了这个 channel 所能传递的元素类型。示例：
var a chan int //声明一个传递元素类型为int的channel var b chan float64 var c chan string 通道是一个引用类型，初始值为nil，对于值为nil的通道，不论具体是什么类型，它们所属的接收和发送操作都会永久处于阻塞状态。
所以必须手动make初始化，示例：
a := make(chan int) //初始化一个int型的名为a的channel b := make(chan float64) c := make(chan string) 既然是队列，那就有大小，上面没声明具体的大小，被认为是无缓冲的（注意大小是 0，不是 1）也就是说必须有其他goroutine接收，不然就会阻塞在那。声明有缓冲的，指定大小就可以了。</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-4-deadlock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-4-deadlock/</guid><description>4.4 deadlock # 本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/4.concurrent/4.4-deadlock/
4.4.1 什么时候会导致死锁 # 在计算机组成原理里说过 死锁有三个必要条件他们分别是 循环等待、资源共享、非抢占式，在并发中出现通道死锁只有两种情况：
数据要发送，但是没有人接收 数据要接收，但是没有人发送 4.4.2 发送单个值时的死锁 # 牢记这两点问题就很清晰了，复习下之前的例子，会死锁
a := make(chan int) a &amp;lt;- 1 //将数据写入channel z := &amp;lt;-a //从channel中读取数据 有且只有一个协程时，无缓冲的通道 先发送会阻塞在发送，先接收会阻塞在接收处。 发送操作在接收者准备好之前是阻塞的，接收操作在发送之前是阻塞的， 解决办法就是改为缓冲通道，或者使用协程配对 解决方法一,协程配对，先发送还是先接收无所谓只要配对就好
chanInt := make(chan int) go func() { chanInt &amp;lt;- 1 }() res := &amp;lt;-chanInt 解决方法二，缓冲通道
chanInt := make(chan int,1) chanInt &amp;lt;- 2 res := &amp;lt;-chanInt 缓冲通道内部的消息数量用len()函数可以测试出来 缓冲通道的容量可以用cap()测试出来 在满足cap&amp;gt;len时候，因为没有满，发送不会阻塞 在len&amp;gt;0时，因为不为空，所以接收不会阻塞 使用缓冲通道可以让生产者和消费者减少阻塞的可能性，对异步操作更友好，不用等待对方准备，但是容量不应设置过大，不然会占用较多内存。</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-5-select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-5-select/</guid><description>4.5 select # 本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/4.concurrent/4.5-select
4.5.1 select与switch # 让我们来复习一下switch语句，在switch语句中，会逐个匹配case语句(可以是值也可以是表达式)，一个一个的判断过去，直到有符合的语句存在，执行匹配的语句内容后跳出switch。
func demo(number int){ switch{ case number &amp;gt;= 90: fmt.Println(&amp;#34;优秀&amp;#34;) default: fmt.Println(&amp;#34;太搓了&amp;#34;) } } 而 select 用于处理通道，它的语法与 switch 非常类似。每个 case 语句里必须是一个 channel 操作。它既可以用于 channel 的数据接收，也可以用于 channel 的数据发送。
func foo() { chanInt := make(chan int) defer close(chanInt) go func() { select { case data, ok := &amp;lt;-chanInt: if ok { fmt.Println(data) } default: fmt.Println(&amp;#34;全部阻塞&amp;#34;) } }() time.Sleep(time.Second) chanInt &amp;lt;- 1 } 输出1</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-6-cron/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-6-cron/</guid><description>4.6 # 很多时候需要周期性的执行某些操作，就需要用到定时器。定时器有三种思路。
4.6.1 Sleep # 使用休眠，让当前Goroutine休眠一定的时间来实现定时的效果，缺点是程序执行速度不均匀，导致定时周期不均匀。
for{ fmt.Println(time.Now()) time.Sleep(time.Second*1) } 4.6.2 Timer # Go 语言的内置包，指定一个时间开始计时，时间到之后会向外发送通知，发送通知的方式就是使用&amp;lt;-chan Time 返回内容。
第一种方式，直接在需要等待处使用，效果和Sleep一样，一使用就卡在那了内部就是使用了Timer。
fmt.Println(time.Now()) &amp;lt;-time.After(1*time.Second) fmt.Println(time.Now()) 也可以把他拆分开，在任意地方进行等待
timer := time.NewTimer(1 * time.Second) &amp;lt;-timer.C fmt.Println(time.Now()) 但是以上只是做到延迟一次性执行，我们来改造一下，把他变成定时器。
done := make(chan struct{}) timer := time.NewTimer(1 * time.Second) go func () { for { select { case &amp;lt;-timer.C: fmt.Println(time.Now()) timer.Reset(1 * time.Second) case &amp;lt;-done: return } } }() &amp;lt;-time.After(5*time.Second + time.Millisecond*100) done &amp;lt;- struct{}{} 定义子Goroutine的目的是为了防止形成死锁，让定时器最终能退出，在实际项目中可能需要一个永久运行的定时器，一般为了不影响项目主逻辑也会这样定义。如果你的项目就是定时任务，我建议也这么写，这样可以注册很多个定时器互不影响。 done是为了判断执行是否结束，防止主Goroutine提前退出。 这个示例只有两个case，实战中如果有加其他case需要给每个case内都做一次Reset，保证重置定时器。 4.</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-7/</guid><description>&amp;hellip;本节正在编写，未完待续，催更请留言，我会收到邮件 #</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-8-%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-8-%E6%B1%A0/</guid><description>&amp;hellip;本节正在编写，未完待续，催更请留言，我会收到邮件 #</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-9/</guid><description>&amp;hellip;本节正在编写，未完待续，催更请留言，我会收到邮件 #</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/%E5%AE%9E%E6%88%98-%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/%E5%AE%9E%E6%88%98-%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7/</guid><description>&amp;hellip;本节正在编写，未完待续，催更请留言，我会收到邮件 #</description></item></channel></rss>