<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="新手常犯的错误 #   引用： Go 经典译文：50 个 Go 新手易犯的错误（2020版）
 花括号不能放在单独的一行 #  大多数使用花括号的语言中，你可以选择放置花括号的位置。 但 Go 不一样。 Go 在编译时会自动注入分号，花括号单独一行会导致分号注入错误（无需自己书写分号）。 所以 Go 其实是有分号的
错误的范例:
package main import &#34;fmt&#34; func main() { // 错误，不能将左大括号放在单独的行上  fmt.Println(&#34;hello there!&#34;) } 编译错误:
 /tmp/sandbox826898458/main.go:6: 语法错误: { 前出现意外的分号或者新的一行
 正确的写法:
package main import &#34;fmt&#34; func main() { fmt.Println(&#34;works!&#34;) } 未使用的变量 #  如果存在未使用的变量会导致编译失败。但是有一个例外， 只有在函数内部声明的变量未使用才会导致报错，如果你有未使用的全局变量是没问题的，也可以存在未使用的函数参数。
如果给变量赋值但是没有使用该变量值，你的代码仍将无法编译。你需要以某种方式使用变量值以使编译器通过。
错误的范例：
package main var gvar int //not an error  func main() { var one int //error, unused variable  two := 2 //error, unused variable  var three int //error, even though it's assigned 3 on the next line  three = 3 func(unused string) { fmt."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="新手常犯的错误 #   引用： Go 经典译文：50 个 Go 新手易犯的错误（2020版）
 花括号不能放在单独的一行 #  大多数使用花括号的语言中，你可以选择放置花括号的位置。 但 Go 不一样。 Go 在编译时会自动注入分号，花括号单独一行会导致分号注入错误（无需自己书写分号）。 所以 Go 其实是有分号的
错误的范例:
package main import &#34;fmt&#34; func main() { // 错误，不能将左大括号放在单独的行上  fmt.Println(&#34;hello there!&#34;) } 编译错误:
 /tmp/sandbox826898458/main.go:6: 语法错误: { 前出现意外的分号或者新的一行
 正确的写法:
package main import &#34;fmt&#34; func main() { fmt.Println(&#34;works!&#34;) } 未使用的变量 #  如果存在未使用的变量会导致编译失败。但是有一个例外， 只有在函数内部声明的变量未使用才会导致报错，如果你有未使用的全局变量是没问题的，也可以存在未使用的函数参数。
如果给变量赋值但是没有使用该变量值，你的代码仍将无法编译。你需要以某种方式使用变量值以使编译器通过。
错误的范例：
package main var gvar int //not an error  func main() { var one int //error, unused variable  two := 2 //error, unused variable  var three int //error, even though it's assigned 3 on the next line  three = 3 func(unused string) { fmt."><meta property="og:type" content="article"><meta property="og:url" content="https://golang.coding3min.com/impossible/%E6%96%B0%E6%89%8B%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/"><meta property="article:section" content="impossible"><title>新手常犯的错误 | Go语言精进之路</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.97d6fd8434748d9af01ffa8b1456ffbaffb5e5f41fd27203ca2eb6697f051143.js integrity="sha256-l9b9hDR0jZrwH/qLFFb/uv+15fQf0nIDyi62aX8FEUM=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>Go语言精进之路</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://coding3min.com>机智的程序员小熊</a></li><li><a href=https://github.com/minibear2333/>GitHub</a></li><li><a href=/qrcode/>微信公众号</a></li><li><strong>帮助与提示</strong><ul><li><a href=/howtocontribute/>0.0 如何参与贡献</a></li><li><a href=/books-share/>0.1 书籍推荐</a></li></ul></li><li><strong>第一章、Go基础</strong><ul><li><a href=/1.base/1-1-install-download/>1.1 安装与下载</a></li><li><a href=/1.base/1-2-hello-world/>1.2 跑起来</a></li><li><a href=/1.base/1-3-go-mod/>1.3 go mod最佳实践</a></li><li><a href=/1.base/1-4-variables/>1.4 变量与常量</a></li><li><a href=/1.base/1-5-switch%E5%92%8Ctypeswitch/>1.5 switch和type switch</a></li><li><a href=/1.base/1-6-for-range/>1.6 循环</a></li><li><a href=/1.base/1-7-range%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/>1.7 range深度解析</a></li></ul></li><li><strong>第二章、函数和容器</strong><ul><li><a href=/2.func-containers/2-1-func/>2.1 函数简单使用和基本知识解析</a></li><li><a href=/2.func-containers/2-2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/>2.2 匿名函数和闭包</a></li><li><a href=/2.func-containers/2-3-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/>2.3 可变参数</a></li><li><a href=/2.func-containers/2-4-map/>2.4 集合（map）</a></li><li><a href=/2.func-containers/2-5-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/>2.5 数组和切片</a></li></ul></li><li><strong>第三章、语法进阶</strong><ul><li><a href=/3.grammar-advancement/3-1-point/>3.1 指针讨论</a></li><li><a href=/3.grammar-advancement/3-2-struct/>3.2 结构体</a></li><li><a href=/3.grammar-advancement/3-3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/>3.3 接口与多态</a></li><li><a href=/3.grammar-advancement/3-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/>3.4 异常处理</a></li></ul></li><li><strong>第四章、并发和并行</strong><ul><li><a href=/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/>4.1 并发特性</a></li><li><a href=/4.concurrent/4-2-goroutine-wait/>4.2 并发等待</a></li><li><a href=/4.concurrent/4-3-channel/>4.3 channel</a></li><li><a href=/4.concurrent/4-4-deadlock/>4.4 deadlock</a></li><li><a href=/4.concurrent/4-5-select/>4.5 select</a></li><li><a href=/4.concurrent/4-6-timeout/>4.6 设置超时</a></li><li>-并发安全</li><li>-协程池</li><li>-消费者生产者框架</li><li>-GMP调度原理</li></ul></li><li><strong>第五章、标准库</strong><ul><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E4%BB%A3%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/>Go代码基本标准规范</a></li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/>文件操作</a></li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8Fsort%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/>排序</a></li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/flag%E5%8C%85%E8%AF%BB%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE/>命令行操作</a></li><li>-时间处理</li><li>-字符串处理</li><li>-json库</li><li>-http库</li><li>跨平台编译</li><li>模板</li></ul></li><li><strong>第六章、调试与测试</strong><ul><li>-单元测试</li><li>-基准测试</li><li>-mock</li><li>-自动化测试</li><li>-调试</li></ul></li><li><strong>第七章、性能调优</strong><ul><li>-cpu调度</li><li>-内存管理</li><li>-垃圾回收</li><li>-PProf</li><li>-逃逸分析</li><li>-链路追踪</li><li>-自监控</li></ul></li><li><strong>第八章、反射</strong></li><li><strong>第九章、优秀开源组件</strong><ul><li>-日志</li><li>-配置管理</li><li>-接口文档</li><li>-错误码控制</li><li>-数据库连接</li><li>-为开源项目贡献代码</li></ul></li><li><strong>第十章、分布式系统</strong><ul><li>-分布式ID生成器</li><li>-分布式锁</li><li>-分布式一致性算法</li></ul></li><li><strong>第x章、web应用</strong><ul><li>-GRPC</li><li>-Protobuf</li></ul></li><li><strong>第x章、微服务</strong></li><li><strong>第x章、服务治理</strong></li><li><strong>第x章、GO语言版本分析</strong></li><li><strong>第x章、Go语言工程化实践</strong><ul><li>构建约束</li></ul></li><li><strong>番外1、拓展应用</strong><ul><li><a href=/tools/readme/>小工具</a></li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/golang%E6%89%93%E9%95%9C%E5%83%8Fdockerfile%E7%9A%84%E5%86%99%E6%B3%95/>Go与Dockerfile</a></li></ul></li><li><strong>番外2、陷阱与缺陷</strong><ul><li><a href=/impossible/range/readme/>range的第二个值实际上是值拷贝</a></li><li><a href=/impossible/%E6%96%B0%E6%89%8B%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/ class=active>新手常犯的错误</a></li><li><a href=/impossible/%E5%88%9D%E5%AD%A6%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>初学者常犯的错误</a></li><li><a href=/impossible/%E8%BF%9B%E9%98%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>进阶常犯的错误</a></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>新手常犯的错误</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#花括号不能放在单独的一行>花括号不能放在单独的一行</a></li><li><a href=#未使用的变量>未使用的变量</a></li><li><a href=#未使用的导入>未使用的导入</a></li><li><a href=#短变量声明只能在函数内部使用>短变量声明只能在函数内部使用</a></li><li><a href=#使用短变量声明重新声明变量>使用短变量声明重新声明变量</a></li><li><a href=#不能使用短变量声明来设置字段值>不能使用短变量声明来设置字段值</a></li><li><a href=#偶然的变量隐藏>偶然的变量隐藏</a></li><li><a href=#不能使用-nil来初始化没有显式类型的变量>不能使用 「nil」来初始化没有显式类型的变量</a></li><li><a href=#使用-nil-切片和映射>使用 「nil」 切片和映射</a></li><li><a href=#映射容量>映射容量</a></li><li><a href=#字符串不能为nil>字符串不能为「nil」</a></li><li><a href=#数组函数参数>数组函数参数</a></li><li><a href=#切片和数组range子句下的意外值>切片和数组「range」子句下的意外值</a></li><li><a href=#切片和数组是一维的>切片和数组是一维的</a></li><li><a href=#访问不存在的映射键>访问不存在的映射键</a></li><li><a href=#字符串是不可变的>字符串是不可变的</a></li><li><a href=#字符串和字节片之间的转换>字符串和字节片之间的转换</a></li><li><a href=#字符串并不总是-utf8-文本>字符串并不总是 UTF8 文本</a></li><li><a href=#字符串长度>字符串长度</a></li><li><a href=#在多行切片数组和映射字面值中缺少逗号>在多行切片，数组和映射字面值中缺少逗号</a></li><li><a href=#logfatal-与-logpanic-比-log-要做的更多>log.Fatal 与 log.Panic 比 Log 要做的更多</a></li><li><a href=#内置数据结构操作不同步>内置数据结构操作不同步</a></li><li><a href=#range语句对于字符串的操作>「range」语句对于字符串的操作</a></li><li><a href=#switch-语句中的-fallthrough-行为>switch 语句中的 Fallthrough 行为</a></li><li><a href=#发送到无缓冲通道的消息在目标接收器准备就绪后立即返回>发送到无缓冲通道的消息在目标接收器准备就绪后立即返回</a></li><li><a href=#发送到关闭通道会引起崩溃>发送到关闭通道会引起崩溃</a></li></ul></nav></aside></header><article class=markdown><h1 id=新手常犯的错误>新手常犯的错误
<a class=anchor href=#%e6%96%b0%e6%89%8b%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af>#</a></h1><blockquote><p>引用：
<a href=https://learnku.com/go/wikis/49781>Go 经典译文：50 个 Go 新手易犯的错误（2020版）</a></p></blockquote><h2 id=花括号不能放在单独的一行>花括号不能放在单独的一行
<a class=anchor href=#%e8%8a%b1%e6%8b%ac%e5%8f%b7%e4%b8%8d%e8%83%bd%e6%94%be%e5%9c%a8%e5%8d%95%e7%8b%ac%e7%9a%84%e4%b8%80%e8%a1%8c>#</a></h2><p>大多数使用花括号的语言中，你可以选择放置花括号的位置。 但 Go 不一样。 Go 在编译时会自动注入分号，花括号单独一行会导致分号注入错误（无需自己书写分号）。 所以 Go 其实是有分号的</p><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>()  
{ <span style=color:#75715e>// 错误，不能将左大括号放在单独的行上
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;hello there!&#34;</span>)
}
</code></pre></div><p>编译错误:</p><blockquote><p>/tmp/sandbox826898458/main.go:6: 语法错误: <code>{</code> 前出现意外的分号或者新的一行</p></blockquote><p>正确的写法:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;works!&#34;</span>)
}
</code></pre></div><h2 id=未使用的变量>未使用的变量
<a class=anchor href=#%e6%9c%aa%e4%bd%bf%e7%94%a8%e7%9a%84%e5%8f%98%e9%87%8f>#</a></h2><p>如果存在未使用的变量会导致编译失败。但是有一个例外， 只有在函数内部声明的变量未使用才会导致报错，如果你有未使用的全局变量是没问题的，也可以存在未使用的函数参数。</p><p>如果给变量赋值但是没有使用该变量值，你的代码仍将无法编译。你需要以某种方式使用变量值以使编译器通过。</p><p>错误的范例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>gvar</span> <span style=color:#66d9ef>int</span> <span style=color:#75715e>//not an error
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>one</span> <span style=color:#66d9ef>int</span>   <span style=color:#75715e>//error, unused variable
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>two</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span>      <span style=color:#75715e>//error, unused variable
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>three</span> <span style=color:#66d9ef>int</span> <span style=color:#75715e>//error, even though it&#39;s assigned 3 on the next line
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>three</span> = <span style=color:#ae81ff>3</span>

    <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>unused</span> <span style=color:#66d9ef>string</span>) {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Unused arg. No compile error&#34;</span>)
    }(<span style=color:#e6db74>&#34;what?&#34;</span>)
}
</code></pre></div><p>编译错误：</p><blockquote><p>/tmp/sandbox473116179/main.go:6: one declared and not used /tmp/sandbox473116179/main.go:7: two declared and not used /tmp/sandbox473116179/main.go:8: three declared and not used</p></blockquote><p>正确的写法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>one</span> <span style=color:#66d9ef>int</span>
    <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>one</span>

    <span style=color:#a6e22e>two</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span> 
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>two</span>)

    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>three</span> <span style=color:#66d9ef>int</span> 
    <span style=color:#a6e22e>three</span> = <span style=color:#ae81ff>3</span>
    <span style=color:#a6e22e>one</span> = <span style=color:#a6e22e>three</span>

    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>four</span> <span style=color:#66d9ef>int</span>
    <span style=color:#a6e22e>four</span> = <span style=color:#a6e22e>four</span>
}
</code></pre></div><p>另一种选择是注释掉或删除未使用的变量</p><h2 id=未使用的导入>未使用的导入
<a class=anchor href=#%e6%9c%aa%e4%bd%bf%e7%94%a8%e7%9a%84%e5%af%bc%e5%85%a5>#</a></h2><p>如果你导入一个包却没有使用它的任何导出函数，接口，结构体或变量，你的代码将会编译失败。</p><p>如果确实需要导入包，你可以使用空白标识符<code>_</code>作为其包名，以避免此编译失败。对于这些副作用，使用空标识符来导入包。</p><p>错误的范例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;log&#34;</span>
    <span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
}
</code></pre></div><p>编译错误：</p><blockquote><p>/tmp/sandbox627475386/main.go:4：导入但未使用：“fmt” /tmp/sandbox627475386/main.go:5：导入但未使用：“ log” /tmp/sandbox627475386/main.go:6：导入但未使用：“time”</p></blockquote><p>正确的写法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#a6e22e>_</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;log&#34;</span>
    <span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>
}
</code></pre></div><p>另一个选择是删除或注释掉未使用的导入
<a href=http://godoc.org/golang.org/x/tools//goimports><code>goimports</code></a> 工具可以为你提供帮助。</p><h2 id=短变量声明只能在函数内部使用>短变量声明只能在函数内部使用
<a class=anchor href=#%e7%9f%ad%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e%e5%8f%aa%e8%83%bd%e5%9c%a8%e5%87%bd%e6%95%b0%e5%86%85%e9%83%a8%e4%bd%bf%e7%94%a8>#</a></h2><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#a6e22e>myvar</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>//error
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
}
</code></pre></div><p>编译错误:</p><blockquote><p>/tmp/sandbox265716165/main.go:3: non-declaration statement outside function body</p></blockquote><p>正确的写法:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>myvar</span> = <span style=color:#ae81ff>1</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
}
</code></pre></div><h2 id=使用短变量声明重新声明变量>使用短变量声明重新声明变量
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e7%9f%ad%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e%e9%87%8d%e6%96%b0%e5%a3%b0%e6%98%8e%e5%8f%98%e9%87%8f>#</a></h2><p>你不能在独立的语句中重新声明变量，但在至少声明一个新变量的多变量声明中允许这样做。</p><p>重新声明的变量必须位于同一块中，否则最终将得到隐藏变量。</p><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>one</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#a6e22e>one</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>//error
</span><span style=color:#75715e></span>}
</code></pre></div><p>编译错误:</p><blockquote><p>/tmp/sandbox706333626/main.go:5: no new variables on left side of :=</p></blockquote><p>正确的写法:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>one</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#a6e22e>one</span>, <span style=color:#a6e22e>two</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>

    <span style=color:#a6e22e>one</span>,<span style=color:#a6e22e>two</span> = <span style=color:#a6e22e>two</span>,<span style=color:#a6e22e>one</span>
}
</code></pre></div><h2 id=不能使用短变量声明来设置字段值>不能使用短变量声明来设置字段值
<a class=anchor href=#%e4%b8%8d%e8%83%bd%e4%bd%bf%e7%94%a8%e7%9f%ad%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e%e6%9d%a5%e8%ae%be%e7%bd%ae%e5%ad%97%e6%ae%b5%e5%80%bc>#</a></h2><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
  <span style=color:#e6db74>&#34;fmt&#34;</span>
)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>info</span> <span style=color:#66d9ef>struct</span> {  
  <span style=color:#a6e22e>result</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>work</span>() (<span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>error</span>) {  
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>13</span>,<span style=color:#66d9ef>nil</span>  
  }

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#a6e22e>info</span>

  <span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>result</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>work</span>() <span style=color:#75715e>//error
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;info: %+v\n&#34;</span>,<span style=color:#a6e22e>data</span>)
}
</code></pre></div><p>编译错误:</p><blockquote><p>prog.go:18: non-name data.result on left side of :=</p></blockquote><p>尽管有解决这个问题的办法，但它不太可能改变，因为 Rob Pike 喜欢它「按原样」</p><p>使用临时变量或预先声明所有变量并使用标准赋值运算符。</p><p>正确的写法:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
  <span style=color:#e6db74>&#34;fmt&#34;</span>
)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>info</span> <span style=color:#66d9ef>struct</span> {  
  <span style=color:#a6e22e>result</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>work</span>() (<span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>error</span>) {  
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>13</span>,<span style=color:#66d9ef>nil</span>  
  }

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#a6e22e>info</span>

  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
  <span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>result</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>work</span>() <span style=color:#75715e>//ok
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
    <span style=color:#66d9ef>return</span>
  }

  <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;info: %+v\n&#34;</span>,<span style=color:#a6e22e>data</span>) <span style=color:#75715e>//prints: info: {result:13}
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=偶然的变量隐藏>偶然的变量隐藏
<a class=anchor href=#%e5%81%b6%e7%84%b6%e7%9a%84%e5%8f%98%e9%87%8f%e9%9a%90%e8%97%8f>#</a></h2><p>简短的变量声明语法非常方便 （特别是对于那些来自动态语言的变量），以至于可以像对待常规赋值操作一样轻松地对待它。如果你在新的代码块中犯了此错误，将不会有编译器错误，但你的应用程序将无法达到你的期望。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>)     <span style=color:#75715e>//prints 1
</span><span style=color:#75715e></span>    {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>) <span style=color:#75715e>//prints 1
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span>
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>) <span style=color:#75715e>//prints 2
</span><span style=color:#75715e></span>    }
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>)     <span style=color:#75715e>//prints 1 (bad if you need 2)
</span><span style=color:#75715e></span>}
</code></pre></div><p>即使对于有经验的 Go 开发者来说，这也是一个非常常见的陷阱。这很容易出现，可能很难发现。</p><p>你可以使用
<a href=http://godoc.org/golang.org/x/tools//vet><code>vet</code></a> 命令来查找其中的一些问题。默认情况下，<code>vet</code> 将不执行任何隐藏变量的检查。确保使用 <code>-shadow</code> 标志：<code>go tool vet -shadow your_file.go</code></p><p>注意，<code>vet</code> 命令不会报告所有的隐藏变量。使用
<a href=https://github.com/barakmich/go-nyet><code>go-nyet</code></a> 进行更全面的隐藏变量检查。</p><h2 id=不能使用-nil来初始化没有显式类型的变量>不能使用 「nil」来初始化没有显式类型的变量
<a class=anchor href=#%e4%b8%8d%e8%83%bd%e4%bd%bf%e7%94%a8-nil%e6%9d%a5%e5%88%9d%e5%a7%8b%e5%8c%96%e6%b2%a1%e6%9c%89%e6%98%be%e5%bc%8f%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%8f%98%e9%87%8f>#</a></h2><p>「nil」标识符可以用作接口，函数，指针，映射，切片和通道的「零值」。如果不指定变量类型，则编译器将无法编译代码，因为它无法猜测类型。</p><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> = <span style=color:#66d9ef>nil</span> <span style=color:#75715e>//error
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>x</span>
}
</code></pre></div><p>编译错误:</p><blockquote><p>/tmp/sandbox188239583/main.go:4: use of untyped nil</p></blockquote><p>正确的写法:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>interface</span>{} = <span style=color:#66d9ef>nil</span>

    <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>x</span>
}
</code></pre></div><h2 id=使用-nil-切片和映射>使用 「nil」 切片和映射
<a class=anchor href=#%e4%bd%bf%e7%94%a8-nil-%e5%88%87%e7%89%87%e5%92%8c%e6%98%a0%e5%b0%84>#</a></h2><p>可以将数据添加到「nil」切片中，但是对映射执行相同操作会产生运行时崩溃 （runtime panic）。</p><p>正确的写法:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s</span> []<span style=color:#66d9ef>int</span>
    <span style=color:#a6e22e>s</span> = append(<span style=color:#a6e22e>s</span>,<span style=color:#ae81ff>1</span>)
}
</code></pre></div><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>m</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>
    <span style=color:#a6e22e>m</span>[<span style=color:#e6db74>&#34;one&#34;</span>] = <span style=color:#ae81ff>1</span> <span style=color:#75715e>//error
</span><span style=color:#75715e></span>
}
</code></pre></div><h2 id=映射容量>映射容量
<a class=anchor href=#%e6%98%a0%e5%b0%84%e5%ae%b9%e9%87%8f>#</a></h2><p>你可以在创建映射时指定映射的容量，但不能在映射中使用 <code>cap()</code> 函数。</p><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>,<span style=color:#ae81ff>99</span>)
    cap(<span style=color:#a6e22e>m</span>) <span style=color:#75715e>//error
</span><span style=color:#75715e></span>}
</code></pre></div><p>编译错误:</p><blockquote><p>/tmp/sandbox326543983/main.go:5: invalid argument m （type map[string]int） for cap</p></blockquote><h2 id=字符串不能为nil>字符串不能为「nil」
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%8d%e8%83%bd%e4%b8%banil>#</a></h2><p>对于习惯于为字符串变量分配「nil」标识符的开发人员来说，这是一个陷阱。</p><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>string</span> = <span style=color:#66d9ef>nil</span> <span style=color:#75715e>//error
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>//error
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>x</span> = <span style=color:#e6db74>&#34;default&#34;</span>
    }
}
</code></pre></div><p>编译错误:</p><blockquote><p>/tmp/sandbox630560459/main.go:4: cannot use nil as type string in assignment /tmp/sandbox630560459/main.go:6: invalid operation: x == nil （mismatched types string and nil）</p></blockquote><p>正确的写法:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>string</span> <span style=color:#75715e>//defaults to &#34;&#34; (zero value)
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
        <span style=color:#a6e22e>x</span> = <span style=color:#e6db74>&#34;default&#34;</span>
    }
}
</code></pre></div><h2 id=数组函数参数>数组函数参数
<a class=anchor href=#%e6%95%b0%e7%bb%84%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0>#</a></h2><p>如果你是 C 或 C++ 开发者，那么你的数组是指针。当你将数组传递给函数时，这些函数将引用相同的内存位置，因此它们可以更新原始数据。Go 中的数组是值，因此当你将数组传递给函数时，这些函数会获取原始数组数据的副本。如果你尝试更新数组数据，则可能会出现问题。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>}

    <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>arr</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>) {
        <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>7</span>
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>arr</span>) <span style=color:#75715e>//prints [7 2 3]
</span><span style=color:#75715e></span>    }(<span style=color:#a6e22e>x</span>)

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>) <span style=color:#75715e>//prints [1 2 3] (not ok if you need [7 2 3])
</span><span style=color:#75715e></span>}
</code></pre></div><p>如果你需要更新原始数组数据，请使用数组指针类型。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>}

    <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>arr</span> <span style=color:#f92672>*</span>[<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>) {
        (<span style=color:#f92672>*</span><span style=color:#a6e22e>arr</span>)[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>7</span>
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>arr</span>) <span style=color:#75715e>//prints &amp;[7 2 3]
</span><span style=color:#75715e></span>    }(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>x</span>)

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>) <span style=color:#75715e>//prints [7 2 3]
</span><span style=color:#75715e></span>}
</code></pre></div><p>另一种选择是使用切片。即使你的函数获得了切片变量的副本，它仍然引用原始数据。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>}

    <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>arr</span> []<span style=color:#66d9ef>int</span>) {
        <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>7</span>
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>arr</span>) <span style=color:#75715e>//prints [7 2 3]
</span><span style=color:#75715e></span>    }(<span style=color:#a6e22e>x</span>)

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>) <span style=color:#75715e>//prints [7 2 3]
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=切片和数组range子句下的意外值>切片和数组「range」子句下的意外值
<a class=anchor href=#%e5%88%87%e7%89%87%e5%92%8c%e6%95%b0%e7%bb%84range%e5%ad%90%e5%8f%a5%e4%b8%8b%e7%9a%84%e6%84%8f%e5%a4%96%e5%80%bc>#</a></h2><p>如果你习惯于使用其他语言的「for-in」或 「foreach」语句，则可能发生这种情况。Go 中的「range」子句不同。它生成两个值：第一个值是索引，而第二个值是数据。</p><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;a&#34;</span>,<span style=color:#e6db74>&#34;b&#34;</span>,<span style=color:#e6db74>&#34;c&#34;</span>}

    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>x</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>v</span>) <span style=color:#75715e>//prints 0, 1, 2
</span><span style=color:#75715e></span>    }
}
</code></pre></div><p>正确的写法:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;a&#34;</span>,<span style=color:#e6db74>&#34;b&#34;</span>,<span style=color:#e6db74>&#34;c&#34;</span>}

    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>x</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>v</span>) <span style=color:#75715e>//prints a, b, c
</span><span style=color:#75715e></span>    }
}
</code></pre></div><h2 id=切片和数组是一维的>切片和数组是一维的
<a class=anchor href=#%e5%88%87%e7%89%87%e5%92%8c%e6%95%b0%e7%bb%84%e6%98%af%e4%b8%80%e7%bb%b4%e7%9a%84>#</a></h2><p>Go 看起来它支持多维数组和切片，但它并不支持。创建数组的数组或切片的切片是可能的。对于依赖于动态多维数组的数值计算应用程序来说，在性能和复杂性方面远远不够理想。</p><p>你可以使用原始的一维数组，「独立」切片的切片以及「共享数据」切片的切片来构建动态多维数组。</p><p>如果使用的是原始一维数组，则需要在数组增长时负责索引，边界检查和内存重新分配。</p><p>使用「独立」切片的切片创建动态多维数组是一个两步过程。首先，你必须创建外部切片。然后，你必须分配每个内部切片。内部切片彼此独立。你可以扩大和缩小它们，而不会影响其他内部切片。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span>
    <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>4</span>

    <span style=color:#a6e22e>table</span> <span style=color:#f92672>:=</span> make([][]<span style=color:#66d9ef>int</span>,<span style=color:#a6e22e>x</span>)
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>table</span> {
        <span style=color:#a6e22e>table</span>[<span style=color:#a6e22e>i</span>] = make([]<span style=color:#66d9ef>int</span>,<span style=color:#a6e22e>y</span>)
    }
}
</code></pre></div><p>使用 「共享数据」切片的切片创建动态多维数组是一个三步过程。首先，你必须创建保存原始数据的数据「容器」切片。然后，创建外部切片。最后，通过重新排列原始数据切片来初始化每个内部切片。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>

    <span style=color:#a6e22e>raw</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>,<span style=color:#a6e22e>h</span><span style=color:#f92672>*</span><span style=color:#a6e22e>w</span>)
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>raw</span> {
        <span style=color:#a6e22e>raw</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>i</span>
    }
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>raw</span>,<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>raw</span>[<span style=color:#ae81ff>4</span>])
    <span style=color:#75715e>//prints: [0 1 2 3 4 5 6 7] &lt;ptr_addr_x&gt;
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>table</span> <span style=color:#f92672>:=</span> make([][]<span style=color:#66d9ef>int</span>,<span style=color:#a6e22e>h</span>)
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>table</span> {
        <span style=color:#a6e22e>table</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>raw</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>*</span><span style=color:#a6e22e>w</span>:<span style=color:#a6e22e>i</span><span style=color:#f92672>*</span><span style=color:#a6e22e>w</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>w</span>]
    }

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>table</span>,<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>table</span>[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>])
    <span style=color:#75715e>//prints: [[0 1 2 3] [4 5 6 7]] &lt;ptr_addr_x&gt;
</span><span style=color:#75715e></span>}
</code></pre></div><p>对于多维数组和切片有一个规范 / 建议，但目前看来这是低优先级的功能。</p><h2 id=访问不存在的映射键>访问不存在的映射键
<a class=anchor href=#%e8%ae%bf%e9%97%ae%e4%b8%8d%e5%ad%98%e5%9c%a8%e7%9a%84%e6%98%a0%e5%b0%84%e9%94%ae>#</a></h2><p>对于希望获得「nil」标识符的开发人员来说这是一个陷阱 （就像其他语言一样）。如果相应数据类型的「零值」为「 nil」，则返回值将为「 nil」，但对于其他数据类型，返回值将不同。检查适当的「零值」可用于确定映射记录是否存在，但是并不总是可靠的 （例如，如果你的布尔值映射中「零值」为 false，你会怎么做）。知道给定映射记录是否存在的最可靠方法是检查由映射访问操作返回的第二个值。</p><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;one&#34;</span>:<span style=color:#e6db74>&#34;a&#34;</span>,<span style=color:#e6db74>&#34;two&#34;</span>:<span style=color:#e6db74>&#34;&#34;</span>,<span style=color:#e6db74>&#34;three&#34;</span>:<span style=color:#e6db74>&#34;c&#34;</span>}

    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>x</span>[<span style=color:#e6db74>&#34;two&#34;</span>]; <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> { <span style=color:#75715e>//incorrect
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;no entry&#34;</span>)
    }
}
</code></pre></div><p>正确的写法:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;one&#34;</span>:<span style=color:#e6db74>&#34;a&#34;</span>,<span style=color:#e6db74>&#34;two&#34;</span>:<span style=color:#e6db74>&#34;&#34;</span>,<span style=color:#e6db74>&#34;three&#34;</span>:<span style=color:#e6db74>&#34;c&#34;</span>}

    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>,<span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>x</span>[<span style=color:#e6db74>&#34;two&#34;</span>]; !<span style=color:#a6e22e>ok</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;no entry&#34;</span>)
    }
}
</code></pre></div><h2 id=字符串是不可变的>字符串是不可变的
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%98%af%e4%b8%8d%e5%8f%af%e5%8f%98%e7%9a%84>#</a></h2><p>尝试使用索引运算符更新字符串变量中的单个字符将导致失败。字符串是只读字节片 （具有一些其他属性）。如果确实需要更新字符串，则在必要时使用字节片而不是将其转换为字符串类型。</p><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;text&#34;</span>
    <span style=color:#a6e22e>x</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#e6db74>&#39;T&#39;</span>

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>)
}
</code></pre></div><p>编译错误:</p><blockquote><p>/tmp/sandbox305565531/main.go:7: cannot assign to x[0]</p></blockquote><p>正确的用法:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;text&#34;</span>
    <span style=color:#a6e22e>xbytes</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#a6e22e>x</span>)
    <span style=color:#a6e22e>xbytes</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#e6db74>&#39;T&#39;</span>

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(string(<span style=color:#a6e22e>xbytes</span>)) <span style=color:#75715e>//prints Text
</span><span style=color:#75715e></span>}
</code></pre></div><p>请注意，这不是真正更新文本字符串中字符的正确方法，因为给定字符可以存储在多个字节中。如果确实需要更新文本字符串，请先将其转换为符文切片。即使使用符文切片，单个字符也可能跨越多个符文。例如，如果你的字符带有重音符号，则可能会发生这种情况。「字符」的这种复杂和模凌两可的性质是将 Go 字符串表示为字节序列的原因。</p><h2 id=字符串和字节片之间的转换>字符串和字节片之间的转换
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%92%8c%e5%ad%97%e8%8a%82%e7%89%87%e4%b9%8b%e9%97%b4%e7%9a%84%e8%bd%ac%e6%8d%a2>#</a></h2><p>当你将字符串转换为字节片 （反之亦然） 时，你将获得原始数据的完整副本。这不像其他语言中的强制转换操作，也不像在新切片变量指向原始字节片所使用的相同基础数组的切片一样。</p><p>Go 对于 <code>[]byte</code> 转 <code>string</code> ，和 <code>string</code> 转 <code>[]byte</code> 确实做了一些优化，以免转换额外分配 （在待办事项列表中还对此进行了更多的优化）</p><p>第一个优化避免了在 <code>map[string]</code> 获取 <code>m[string(key)]</code> 中使用 <code>[]byte</code> 的 keys 查找条目时的额外分配。</p><p>第二个优化避免了在 <code>for range</code> 字符串被转换的语句 <code>[]byte</code>: <code>for i,v := range []byte(str) {...}</code>.</p><h2 id=字符串并不总是-utf8-文本>字符串并不总是 UTF8 文本
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%b9%b6%e4%b8%8d%e6%80%bb%e6%98%af-utf8-%e6%96%87%e6%9c%ac>#</a></h2><ul><li>等级：新手</li></ul><p>字符串的值不一定是 UTF8 文本。它们可以包含任意字节。只有在使用字符串字面值时，字符串才是 UTF8。即使这样，它们也可以使用转译序列包括其他数据。若要了解你是否具有 UTF8 文本字符串，请使用 「unicode/uft8」包中的函数 <code>ValidString()</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;unicode/utf8&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>data1</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;ABC&#34;</span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>utf8</span>.<span style=color:#a6e22e>ValidString</span>(<span style=color:#a6e22e>data1</span>)) <span style=color:#75715e>//prints: true
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>data2</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;A\xfeC&#34;</span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>utf8</span>.<span style=color:#a6e22e>ValidString</span>(<span style=color:#a6e22e>data2</span>)) <span style=color:#75715e>//prints: false
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=字符串长度>字符串长度
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%95%bf%e5%ba%a6>#</a></h2><ul><li>等级：新手</li></ul><p>假设你是 python 开发者，并且使用下面的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>data</span> = <span style=color:#a6e22e>u</span><span style=color:#e6db74>&#39;♥&#39;</span>  
print(len(<span style=color:#a6e22e>data</span>)) <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>prints</span>: <span style=color:#ae81ff>1</span>  
</code></pre></div><p>当你将其转换为类似的 Go 代码时，你可能会感到惊讶。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;♥&#34;</span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(len(<span style=color:#a6e22e>data</span>)) <span style=color:#75715e>//prints: 3
</span><span style=color:#75715e></span>}
</code></pre></div><p>内置的 <code>len()</code> 函数返回字节数而不是字符数，就像 Python 中对 unicode 字符串所做的那样。</p><p>要在 Go 中获得相同的结果，请使用 「unicode/utf8」包中的 <code>RuneCountInString()</code> 函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;unicode/utf8&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;♥&#34;</span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>utf8</span>.<span style=color:#a6e22e>RuneCountInString</span>(<span style=color:#a6e22e>data</span>)) <span style=color:#75715e>//prints: 1
</span></code></pre></div><p>从技术上讲， <code>RuneCountInString()</code> 函数不会返回字符数，因为单个字符可能跨越多个符文。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;unicode/utf8&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;é&#34;</span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(len(<span style=color:#a6e22e>data</span>))                    <span style=color:#75715e>//prints: 3
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>utf8</span>.<span style=color:#a6e22e>RuneCountInString</span>(<span style=color:#a6e22e>data</span>)) <span style=color:#75715e>//prints: 2
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=在多行切片数组和映射字面值中缺少逗号>在多行切片，数组和映射字面值中缺少逗号
<a class=anchor href=#%e5%9c%a8%e5%a4%9a%e8%a1%8c%e5%88%87%e7%89%87%e6%95%b0%e7%bb%84%e5%92%8c%e6%98%a0%e5%b0%84%e5%ad%97%e9%9d%a2%e5%80%bc%e4%b8%ad%e7%bc%ba%e5%b0%91%e9%80%97%e5%8f%b7>#</a></h2><ul><li>等级：新手</li></ul><p>错误的范例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{
    <span style=color:#ae81ff>1</span>,
    <span style=color:#ae81ff>2</span> <span style=color:#75715e>//error
</span><span style=color:#75715e></span>    }
    <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>x</span>
}
</code></pre></div><p>编译错误:</p><blockquote><p>/tmp/sandbox367520156/main.go:6: syntax error: need trailing comma before newline in composite literal /tmp/sandbox367520156/main.go:8: non-declaration statement outside function body /tmp/sandbox367520156/main.go:9: syntax error: unexpected }</p></blockquote><p>正确的写法:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{
    <span style=color:#ae81ff>1</span>,
    <span style=color:#ae81ff>2</span>,
    }
    <span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>x</span>

    <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,} <span style=color:#75715e>//no error
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>y</span> = <span style=color:#a6e22e>y</span>
}
</code></pre></div><p>如果在声明折叠为一行时留下逗号，则不会出现编译错误。</p><h2 id=logfatal-与-logpanic-比-log-要做的更多>log.Fatal 与 log.Panic 比 Log 要做的更多
<a class=anchor href=#logfatal-%e4%b8%8e-logpanic-%e6%af%94-log-%e8%a6%81%e5%81%9a%e7%9a%84%e6%9b%b4%e5%a4%9a>#</a></h2><ul><li>级别：新手</li></ul><p>日志库通常提供不同的日志级别。与那些日志记录库不同，Go 中的日志包的作用远不止于日志记录。如果在你的应用中调用 Go 的 <code>Fatal *()</code> 和 <code>Panic *()</code> 函数，Go 将会终止你的应用</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;log&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalln</span>(<span style=color:#e6db74>&#34;Fatal Level: log entry&#34;</span>) <span style=color:#75715e>//app exits here
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Normal Level: log entry&#34;</span>)
}
</code></pre></div><h2 id=内置数据结构操作不同步>内置数据结构操作不同步
<a class=anchor href=#%e5%86%85%e7%bd%ae%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%93%8d%e4%bd%9c%e4%b8%8d%e5%90%8c%e6%ad%a5>#</a></h2><ul><li>等级：新手</li></ul><p>尽管 Go 有很多支持并发的原生特性，但是并发安全的数据集合不在这些特性中。开发者需要保证对这些数据集合的并发更新操作是原子性的，比如对 map 的并发更新。Go 推荐使用 channels 来实现对集合数据的原子性操作。当然如果「sync」包更适合你的应用也可以利用「sync」包来实现。</p><h2 id=range语句对于字符串的操作>「range」语句对于字符串的操作
<a class=anchor href=#range%e8%af%ad%e5%8f%a5%e5%af%b9%e4%ba%8e%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e6%93%8d%e4%bd%9c>#</a></h2><ul><li>等级：新手</li></ul><p>「range」语句的第一个返回值是当前「字符」（该字符可能是 unicode 码点 /rune）的第一个字节在字符串中按字节的索引值（unicode 是多字节编码），「range」语句的第二个返回值是当前的「字符」。这是 Go 其他语言不同的地方，其他语言的迭代操作大多是返回当前字符的位置，但 Go「range」返回的并不是当前字符的位置。在实际的使用中一个字符可能是由多个 rune 表示的，所以当我们需要处理字符时强烈推荐使用「norm」包（golang.org/x/text/unicode/norm）。</p><p>带有字符串变量的 <code>for range</code> 子句将尝试把数据解释为 UTF8 文本。对于任何它无法理解的字节序列，它将返回 <code>0xfffd</code> runes （即 Unicode 替换字符），而不是实际数据。如果你在字符串变量中存储了任意 （非 UTF8 文本） 数据，请确保将其转换为字节切片，以按原样获取所有存储的数据。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;A\xfe\x02\xff\x04&#34;</span>
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>,<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>data</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%#x &#34;</span>,<span style=color:#a6e22e>v</span>)
    }
    <span style=color:#75715e>//prints: 0x41 0xfffd 0x2 0xfffd 0x4 (not ok)
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>()
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>,<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> []byte(<span style=color:#a6e22e>data</span>) {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%#x &#34;</span>,<span style=color:#a6e22e>v</span>)
    }
    <span style=color:#75715e>//prints: 0x41 0xfe 0x2 0xff 0x4 (good)
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=switch-语句中的-fallthrough-行为>switch 语句中的 Fallthrough 行为
<a class=anchor href=#switch-%e8%af%ad%e5%8f%a5%e4%b8%ad%e7%9a%84-fallthrough-%e8%a1%8c%e4%b8%ba>#</a></h2><ul><li>级别：新手</li></ul><p>在 &ldquo;switch&rdquo; 语句中的 &ldquo;case&rdquo; 块，其缺省行为是 break 出 &ldquo;switch&rdquo;。这一行为与其它语言不同，其它语言的缺省行为是，继续执行下一个 &ldquo;case&rdquo; 块。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>isSpace</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ch</span> <span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>bool</span> {
        <span style=color:#66d9ef>switch</span>(<span style=color:#a6e22e>ch</span>) {
        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39; &#39;</span>: <span style=color:#75715e>//error
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;\t&#39;</span>:
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
        }
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
    }

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>isSpace</span>(<span style=color:#e6db74>&#39;\t&#39;</span>)) <span style=color:#75715e>//prints true (ok)
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>isSpace</span>(<span style=color:#e6db74>&#39; &#39;</span>))  <span style=color:#75715e>//prints false (not ok)
</span><span style=color:#75715e></span>}
</code></pre></div><p>你可以通过在每个 &ldquo;case&rdquo; 块的最后加入 &ldquo;fallthrough&rdquo; 语句来迫使 &ldquo;case&rdquo; 块继续往下执行。你也可以重写你的 &ldquo;switch&rdquo; 语句，在 &ldquo;case&rdquo; 块中使用表达式列表来达到这一目的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>isSpace</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ch</span> <span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>bool</span> {
        <span style=color:#66d9ef>switch</span>(<span style=color:#a6e22e>ch</span>) {
        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39; &#39;</span>, <span style=color:#e6db74>&#39;\t&#39;</span>:
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
        }
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
    }

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>isSpace</span>(<span style=color:#e6db74>&#39;\t&#39;</span>)) <span style=color:#75715e>//prints true (ok)
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>isSpace</span>(<span style=color:#e6db74>&#39; &#39;</span>))  <span style=color:#75715e>//prints true (ok)
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=发送到无缓冲通道的消息在目标接收器准备就绪后立即返回>发送到无缓冲通道的消息在目标接收器准备就绪后立即返回
<a class=anchor href=#%e5%8f%91%e9%80%81%e5%88%b0%e6%97%a0%e7%bc%93%e5%86%b2%e9%80%9a%e9%81%93%e7%9a%84%e6%b6%88%e6%81%af%e5%9c%a8%e7%9b%ae%e6%a0%87%e6%8e%a5%e6%94%b6%e5%99%a8%e5%87%86%e5%a4%87%e5%b0%b1%e7%bb%aa%e5%90%8e%e7%ab%8b%e5%8d%b3%e8%bf%94%e5%9b%9e>#</a></h2><ul><li>等级：新手</li></ul><p>直到接收方处理完你的消息后，发送才会被阻止。根据运行代码的机器，接收方 goroutine 可能会或可能没有足够的时间在发送方继续执行之前处理消息。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>)

    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>ch</span> {
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;processed:&#34;</span>,<span style=color:#a6e22e>m</span>)
        }
    }()

    <span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#e6db74>&#34;.1&#34;</span>
    <span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#e6db74>&#34;.2&#34;</span> <span style=color:#75715e>//won&#39;t be processed
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=发送到关闭通道会引起崩溃>发送到关闭通道会引起崩溃
<a class=anchor href=#%e5%8f%91%e9%80%81%e5%88%b0%e5%85%b3%e9%97%ad%e9%80%9a%e9%81%93%e4%bc%9a%e5%bc%95%e8%b5%b7%e5%b4%a9%e6%ba%83>#</a></h2><ul><li>等级：新手</li></ul><p>从关闭的通道接收是安全的。接收语句中的 <code>ok</code> 返回值将设置为 <code>false</code> 表示未接收到任何数据。如果你是从缓冲通道接收到的数据，则将首先获取缓冲数据，一旦缓冲数据为空，返回的 <code>ok</code> 返回值将为 <code>false</code>。</p><p>发送数据到一个已经关闭的 <code>channel</code> 会触发 <code>panic</code>。 这是一个不容争论的事实，但是对于一个 Go 开发新手来说这样的事实可能不太容易理解，可能会更期望发送行为像接收行为那样。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>3</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>idx</span> <span style=color:#66d9ef>int</span>) {
            <span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> (<span style=color:#a6e22e>idx</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
        }(<span style=color:#a6e22e>i</span>)
    }

    <span style=color:#75715e>//获取第一个结果
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>)
    close(<span style=color:#a6e22e>ch</span>) <span style=color:#75715e>//这样做很不好 (因为在协程中还有动作在向 channel 发送数据)
</span><span style=color:#75715e></span>    <span style=color:#75715e>//做些其他的事情
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
}
</code></pre></div><p>根据你的应用程序，修复这样的程序将会有所不同。修改细微的代码不让 <code>panic</code> 中断程序是次要的，因为可能你更加需要修改程序的逻辑设计。无论哪种方式，你都需要确保你的应用程序不会在 <code>channel</code> 已经关闭的情况下发送数据给它。</p><p>可以通过使用特殊的取消渠道来通知剩余的工作人员不再需要他们的结果，从而解决该示例问题。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (  
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
    <span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
    <span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{})
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>3</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>idx</span> <span style=color:#66d9ef>int</span>) {
            <span style=color:#66d9ef>select</span> {
            <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> (<span style=color:#a6e22e>idx</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>: <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>idx</span>,<span style=color:#e6db74>&#34;sent result&#34;</span>)
            <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>done</span>: <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>idx</span>,<span style=color:#e6db74>&#34;exiting&#34;</span>)
            }
        }(<span style=color:#a6e22e>i</span>)
    }

    <span style=color:#75715e>//get first result
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;result:&#34;</span>,<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>)
    close(<span style=color:#a6e22e>done</span>)
    <span style=color:#75715e>//do other work
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
}
</code></pre></div></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=minibear2333/blog-comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/golang-minibear2333/golang/edit/master/./impossible/%e6%96%b0%e6%89%8b%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#花括号不能放在单独的一行>花括号不能放在单独的一行</a></li><li><a href=#未使用的变量>未使用的变量</a></li><li><a href=#未使用的导入>未使用的导入</a></li><li><a href=#短变量声明只能在函数内部使用>短变量声明只能在函数内部使用</a></li><li><a href=#使用短变量声明重新声明变量>使用短变量声明重新声明变量</a></li><li><a href=#不能使用短变量声明来设置字段值>不能使用短变量声明来设置字段值</a></li><li><a href=#偶然的变量隐藏>偶然的变量隐藏</a></li><li><a href=#不能使用-nil来初始化没有显式类型的变量>不能使用 「nil」来初始化没有显式类型的变量</a></li><li><a href=#使用-nil-切片和映射>使用 「nil」 切片和映射</a></li><li><a href=#映射容量>映射容量</a></li><li><a href=#字符串不能为nil>字符串不能为「nil」</a></li><li><a href=#数组函数参数>数组函数参数</a></li><li><a href=#切片和数组range子句下的意外值>切片和数组「range」子句下的意外值</a></li><li><a href=#切片和数组是一维的>切片和数组是一维的</a></li><li><a href=#访问不存在的映射键>访问不存在的映射键</a></li><li><a href=#字符串是不可变的>字符串是不可变的</a></li><li><a href=#字符串和字节片之间的转换>字符串和字节片之间的转换</a></li><li><a href=#字符串并不总是-utf8-文本>字符串并不总是 UTF8 文本</a></li><li><a href=#字符串长度>字符串长度</a></li><li><a href=#在多行切片数组和映射字面值中缺少逗号>在多行切片，数组和映射字面值中缺少逗号</a></li><li><a href=#logfatal-与-logpanic-比-log-要做的更多>log.Fatal 与 log.Panic 比 Log 要做的更多</a></li><li><a href=#内置数据结构操作不同步>内置数据结构操作不同步</a></li><li><a href=#range语句对于字符串的操作>「range」语句对于字符串的操作</a></li><li><a href=#switch-语句中的-fallthrough-行为>switch 语句中的 Fallthrough 行为</a></li><li><a href=#发送到无缓冲通道的消息在目标接收器准备就绪后立即返回>发送到无缓冲通道的消息在目标接收器准备就绪后立即返回</a></li><li><a href=#发送到关闭通道会引起崩溃>发送到关闭通道会引起崩溃</a></li></ul></nav></div></aside></main></body></html>