<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Building sys/unix #  The sys/unix package provides access to the raw system call interface of the underlying operating system. See: https://godoc.org/golang.org/x/sys/unix
Porting Go to a new architecture/OS combination or adding syscalls, types, or constants to an existing architecture/OS pair requires some manual effort; however, there are tools that automate much of the process.
Build Systems #  There are currently two ways we generate the necessary files. We are currently migrating the build system to use containers so the builds are reproducible."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="Building sys/unix #  The sys/unix package provides access to the raw system call interface of the underlying operating system. See: https://godoc.org/golang.org/x/sys/unix
Porting Go to a new architecture/OS combination or adding syscalls, types, or constants to an existing architecture/OS pair requires some manual effort; however, there are tools that automate much of the process.
Build Systems #  There are currently two ways we generate the necessary files. We are currently migrating the build system to use containers so the builds are reproducible."><meta property="og:type" content="article"><meta property="og:url" content="https://golang.coding3min.com/1.base/1.3-go-mod/vendor/golang.org/x/sys/unix/readme/"><meta property="article:section" content="1.base"><title>Readme | Go语言精进之路</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.97d6fd8434748d9af01ffa8b1456ffbaffb5e5f41fd27203ca2eb6697f051143.js integrity="sha256-l9b9hDR0jZrwH/qLFFb/uv+15fQf0nIDyi62aX8FEUM=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>Go语言精进之路</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://coding3min.com>机智的程序员小熊</a></li><li><a href=https://github.com/minibear2333/>GitHub</a></li><li><a href=/qrcode/>微信公众号</a></li><li><strong>帮助与提示</strong><ul><li><a href=/howtocontribute/>0.0 如何参与贡献</a></li><li><a href=/books-share/>0.1 书籍推荐</a></li></ul></li><li><strong>第一章、Go基础</strong><ul><li><a href=/1.base/1-1-install-download/>1.1 安装与下载</a></li><li><a href=/1.base/1-2-hello-world/>1.2 跑起来</a></li><li><a href=/1.base/1-3-go-mod/>1.3 go mod最佳实践</a></li><li><a href=/1.base/1-4-variables/>1.4 变量与常量</a></li><li><a href=/1.base/1-5-switch%E5%92%8Ctypeswitch/>1.5 switch和type switch</a></li><li><a href=/1.base/1-6-for-range/>1.6 循环</a></li><li><a href=/1.base/1-7-range%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/>1.7 range深度解析</a></li></ul></li><li><strong>第二章、函数和容器</strong><ul><li><a href=/2.func-containers/2-1-func/>2.1 函数简单使用和基本知识解析</a></li><li><a href=/2.func-containers/2-2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/>2.2 匿名函数和闭包</a></li><li><a href=/2.func-containers/2-3-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/>2.3 可变参数</a></li><li><a href=/2.func-containers/2-4-map/>2.4 集合（map）</a></li><li><a href=/2.func-containers/2-5-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/>2.5 数组和切片</a></li></ul></li><li><strong>第三章、语法进阶</strong><ul><li><a href=/3.grammar-advancement/3-1-point/>3.1 指针讨论</a></li><li><a href=/3.grammar-advancement/3-2-struct/>3.2 结构体</a></li><li><a href=/3.grammar-advancement/3-3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/>3.3 接口与多态</a></li><li><a href=/3.grammar-advancement/3-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/>3.4 异常处理</a></li></ul></li><li><strong>第四章、并发和并行</strong><ul><li><a href=/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/>4.1 并发特性</a></li><li><a href=/4.concurrent/4-2-goroutine-wait/>4.2 并发等待</a></li><li><a href=/4.concurrent/4-3-channel/>4.3 channel</a></li><li><a href=/4.concurrent/4-4-deadlock/>4.4 deadlock</a></li><li><a href=/4.concurrent/4-5-select/>4.5 select</a></li><li><a href=/4.concurrent/4-6-timeout/>4.6 设置超时</a></li><li>-并发安全</li><li>-协程池</li><li>-消费者生产者框架</li><li>-GMP调度原理</li></ul></li><li><strong>第五章、标准库</strong><ul><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E4%BB%A3%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/>Go代码基本标准规范</a></li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/>文件操作</a></li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8Fsort%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/>排序</a></li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/flag%E5%8C%85%E8%AF%BB%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE/>命令行操作</a></li><li>-时间处理</li><li>-字符串处理</li><li>-json库</li><li>-http库</li><li>跨平台编译</li><li>模板</li></ul></li><li><strong>第六章、调试与测试</strong><ul><li>-单元测试</li><li>-基准测试</li><li>-mock</li><li>-自动化测试</li><li>-调试</li></ul></li><li><strong>第七章、性能调优</strong><ul><li>-cpu调度</li><li>-内存管理</li><li>-垃圾回收</li><li>-PProf</li><li>-逃逸分析</li><li>-链路追踪</li><li>-自监控</li></ul></li><li><strong>第八章、反射</strong></li><li><strong>第九章、优秀开源组件</strong><ul><li>-日志</li><li>-配置管理</li><li>-接口文档</li><li>-错误码控制</li><li>-数据库连接</li><li>-为开源项目贡献代码</li></ul></li><li><strong>第十章、分布式系统</strong><ul><li>-分布式ID生成器</li><li>-分布式锁</li><li>-分布式一致性算法</li></ul></li><li><strong>第x章、web应用</strong><ul><li>-GRPC</li><li>-Protobuf</li></ul></li><li><strong>第x章、微服务</strong></li><li><strong>第x章、服务治理</strong></li><li><strong>第x章、GO语言版本分析</strong></li><li><strong>第x章、Go语言工程化实践</strong><ul><li>构建约束</li></ul></li><li><strong>番外1、拓展应用</strong><ul><li><a href=/tools/readme/>小工具</a></li><li><a href=/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/golang%E6%89%93%E9%95%9C%E5%83%8Fdockerfile%E7%9A%84%E5%86%99%E6%B3%95/>Go与Dockerfile</a></li></ul></li><li><strong>番外2、陷阱与缺陷</strong><ul><li><a href=/impossible/range/readme/>range的第二个值实际上是值拷贝</a></li><li><a href=/impossible/%E6%96%B0%E6%89%8B%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>新手常犯的错误</a></li><li><a href=/impossible/%E5%88%9D%E5%AD%A6%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>初学者常犯的错误</a></li><li><a href=/impossible/%E8%BF%9B%E9%98%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>进阶常犯的错误</a></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Readme</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#build-systems>Build Systems</a><ul><li><a href=#old-build-system-currently-for-goos--linux>Old Build System (currently for <code>GOOS != "linux"</code>)</a></li><li><a href=#new-build-system-currently-for-goos--linux>New Build System (currently for <code>GOOS == "linux"</code>)</a></li></ul></li><li><a href=#component-files>Component files</a><ul><li><a href=#asm-files>asm files</a></li><li><a href=#mksysnum>mksysnum</a></li><li><a href=#mksyscallgo>mksyscall.go</a></li><li><a href=#types-files>types files</a></li><li><a href=#mkerrorssh>mkerrors.sh</a></li></ul></li><li><a href=#generated-files>Generated files</a><ul><li><a href=#zerror_goos_goarchgo><code>zerror_${GOOS}_${GOARCH}.go</code></a></li><li><a href=#zsyscall_goos_goarchgo><code>zsyscall_${GOOS}_${GOARCH}.go</code></a></li><li><a href=#zsysnum_goos_goarchgo><code>zsysnum_${GOOS}_${GOARCH}.go</code></a></li><li><a href=#ztypes_goos_goarchgo><code>ztypes_${GOOS}_${GOARCH}.go</code></a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=building-sysunix>Building <code>sys/unix</code>
<a class=anchor href=#building-sysunix>#</a></h1><p>The sys/unix package provides access to the raw system call interface of the
underlying operating system. See: <a href=https://godoc.org/golang.org/x/sys/unix>https://godoc.org/golang.org/x/sys/unix</a></p><p>Porting Go to a new architecture/OS combination or adding syscalls, types, or
constants to an existing architecture/OS pair requires some manual effort;
however, there are tools that automate much of the process.</p><h2 id=build-systems>Build Systems
<a class=anchor href=#build-systems>#</a></h2><p>There are currently two ways we generate the necessary files. We are currently
migrating the build system to use containers so the builds are reproducible.
This is being done on an OS-by-OS basis. Please update this documentation as
components of the build system change.</p><h3 id=old-build-system-currently-for-goos--linux>Old Build System (currently for <code>GOOS != "linux"</code>)
<a class=anchor href=#old-build-system-currently-for-goos--linux>#</a></h3><p>The old build system generates the Go files based on the C header files
present on your system. This means that files
for a given GOOS/GOARCH pair must be generated on a system with that OS and
architecture. This also means that the generated code can differ from system
to system, based on differences in the header files.</p><p>To avoid this, if you are using the old build system, only generate the Go
files on an installation with unmodified header files. It is also important to
keep track of which version of the OS the files were generated from (ex.
Darwin 14 vs Darwin 15). This makes it easier to track the progress of changes
and have each OS upgrade correspond to a single change.</p><p>To build the files for your current OS and architecture, make sure GOOS and
GOARCH are set correctly and run <code>mkall.sh</code>. This will generate the files for
your specific system. Running <code>mkall.sh -n</code> shows the commands that will be run.</p><p>Requirements: bash, go</p><h3 id=new-build-system-currently-for-goos--linux>New Build System (currently for <code>GOOS == "linux"</code>)
<a class=anchor href=#new-build-system-currently-for-goos--linux>#</a></h3><p>The new build system uses a Docker container to generate the go files directly
from source checkouts of the kernel and various system libraries. This means
that on any platform that supports Docker, all the files using the new build
system can be generated at once, and generated files will not change based on
what the person running the scripts has installed on their computer.</p><p>The OS specific files for the new build system are located in the <code>${GOOS}</code>
directory, and the build is coordinated by the <code>${GOOS}/mkall.go</code> program. When
the kernel or system library updates, modify the Dockerfile at
<code>${GOOS}/Dockerfile</code> to checkout the new release of the source.</p><p>To build all the files under the new build system, you must be on an 64/Linux
system and have your GOOS and GOARCH set accordingly. Running <code>mkall.sh</code> will
then generate all of the files for all of the GOOS/GOARCH pairs in the new build
system. Running <code>mkall.sh -n</code> shows the commands that will be run.</p><p>Requirements: bash, go, docker</p><h2 id=component-files>Component files
<a class=anchor href=#component-files>#</a></h2><p>This section describes the various files used in the code generation process.
It also contains instructions on how to modify these files to add a new
architecture/OS or to add additional syscalls, types, or constants. Note that
if you are using the new build system, the scripts/programs cannot be called normally.
They must be called from within the docker container.</p><h3 id=asm-files>asm files
<a class=anchor href=#asm-files>#</a></h3><p>The hand-written assembly file at <code>asm_${GOOS}_${GOARCH}.s</code> implements system
call dispatch. There are three entry points:</p><pre><code>  func Syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)
  func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)
  func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)
</code></pre><p>The first and second are the standard ones; they differ only in how many
arguments can be passed to the kernel. The third is for low-level use by the
ForkExec wrapper. Unlike the first two, it does not call into the scheduler to
let it know that a system call is running.</p><p>When porting Go to an new architecture/OS, this file must be implemented for
each GOOS/GOARCH pair.</p><h3 id=mksysnum>mksysnum
<a class=anchor href=#mksysnum>#</a></h3><p>Mksysnum is a Go program located at <code>${GOOS}/mksysnum.go</code> (or <code>mksysnum_${GOOS}.go</code>
for the old system). This program takes in a list of header files containing the
syscall number declarations and parses them to produce the corresponding list of
Go numeric constants. See <code>zsysnum_${GOOS}_${GOARCH}.go</code> for the generated
constants.</p><p>Adding new syscall numbers is mostly done by running the build on a sufficiently
new installation of the target OS (or updating the source checkouts for the
new build system). However, depending on the OS, you make need to update the
parsing in mksysnum.</p><h3 id=mksyscallgo>mksyscall.go
<a class=anchor href=#mksyscallgo>#</a></h3><p>The <code>syscall.go</code>, <code>syscall_${GOOS}.go</code>, <code>syscall_${GOOS}_${GOARCH}.go</code> are
hand-written Go files which implement system calls (for unix, the specific OS,
or the specific OS/Architecture pair respectively) that need special handling
and list <code>//sys</code> comments giving prototypes for ones that can be generated.</p><p>The mksyscall.go program takes the <code>//sys</code> and <code>//sysnb</code> comments and converts
them into syscalls. This requires the name of the prototype in the comment to
match a syscall number in the <code>zsysnum_${GOOS}_${GOARCH}.go</code> file. The function
prototype can be exported (capitalized) or not.</p><p>Adding a new syscall often just requires adding a new <code>//sys</code> function prototype
with the desired arguments and a capitalized name so it is exported. However, if
you want the interface to the syscall to be different, often one will make an
unexported <code>//sys</code> prototype, an then write a custom wrapper in
<code>syscall_${GOOS}.go</code>.</p><h3 id=types-files>types files
<a class=anchor href=#types-files>#</a></h3><p>For each OS, there is a hand-written Go file at <code>${GOOS}/types.go</code> (or
<code>types_${GOOS}.go</code> on the old system). This file includes standard C headers and
creates Go type aliases to the corresponding C types. The file is then fed
through godef to get the Go compatible definitions. Finally, the generated code
is fed though mkpost.go to format the code correctly and remove any hidden or
private identifiers. This cleaned-up code is written to
<code>ztypes_${GOOS}_${GOARCH}.go</code>.</p><p>The hardest part about preparing this file is figuring out which headers to
include and which symbols need to be <code>#define</code>d to get the actual data
structures that pass through to the kernel system calls. Some C libraries
preset alternate versions for binary compatibility and translate them on the
way in and out of system calls, but there is almost always a <code>#define</code> that can
get the real ones.
See <code>types_darwin.go</code> and <code>linux/types.go</code> for examples.</p><p>To add a new type, add in the necessary include statement at the top of the
file (if it is not already there) and add in a type alias line. Note that if
your type is significantly different on different architectures, you may need
some <code>#if/#elif</code> macros in your include statements.</p><h3 id=mkerrorssh>mkerrors.sh
<a class=anchor href=#mkerrorssh>#</a></h3><p>This script is used to generate the system&rsquo;s various constants. This doesn&rsquo;t
just include the error numbers and error strings, but also the signal numbers
an a wide variety of miscellaneous constants. The constants come from the list
of include files in the <code>includes_${uname}</code> variable. A regex then picks out
the desired <code>#define</code> statements, and generates the corresponding Go constants.
The error numbers and strings are generated from <code>#include &lt;errno.h></code>, and the
signal numbers and strings are generated from <code>#include &lt;signal.h></code>. All of
these constants are written to <code>zerrors_${GOOS}_${GOARCH}.go</code> via a C program,
<code>_errors.c</code>, which prints out all the constants.</p><p>To add a constant, add the header that includes it to the appropriate variable.
Then, edit the regex (if necessary) to match the desired constant. Avoid making
the regex too broad to avoid matching unintended constants.</p><h2 id=generated-files>Generated files
<a class=anchor href=#generated-files>#</a></h2><h3 id=zerror_goos_goarchgo><code>zerror_${GOOS}_${GOARCH}.go</code>
<a class=anchor href=#zerror_goos_goarchgo>#</a></h3><p>A file containing all of the system&rsquo;s generated error numbers, error strings,
signal numbers, and constants. Generated by <code>mkerrors.sh</code> (see above).</p><h3 id=zsyscall_goos_goarchgo><code>zsyscall_${GOOS}_${GOARCH}.go</code>
<a class=anchor href=#zsyscall_goos_goarchgo>#</a></h3><p>A file containing all the generated syscalls for a specific GOOS and GOARCH.
Generated by <code>mksyscall.go</code> (see above).</p><h3 id=zsysnum_goos_goarchgo><code>zsysnum_${GOOS}_${GOARCH}.go</code>
<a class=anchor href=#zsysnum_goos_goarchgo>#</a></h3><p>A list of numeric constants for all the syscall number of the specific GOOS
and GOARCH. Generated by mksysnum (see above).</p><h3 id=ztypes_goos_goarchgo><code>ztypes_${GOOS}_${GOARCH}.go</code>
<a class=anchor href=#ztypes_goos_goarchgo>#</a></h3><p>A file containing Go types for passing into (or returning from) syscalls.
Generated by godefs and the types file (see above).</p></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=minibear2333/blog-comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/golang-minibear2333/golang/edit/master/./1.base/1.3-go-mod/vendor/golang.org/x/sys/unix/README.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#build-systems>Build Systems</a><ul><li><a href=#old-build-system-currently-for-goos--linux>Old Build System (currently for <code>GOOS != "linux"</code>)</a></li><li><a href=#new-build-system-currently-for-goos--linux>New Build System (currently for <code>GOOS == "linux"</code>)</a></li></ul></li><li><a href=#component-files>Component files</a><ul><li><a href=#asm-files>asm files</a></li><li><a href=#mksysnum>mksysnum</a></li><li><a href=#mksyscallgo>mksyscall.go</a></li><li><a href=#types-files>types files</a></li><li><a href=#mkerrorssh>mkerrors.sh</a></li></ul></li><li><a href=#generated-files>Generated files</a><ul><li><a href=#zerror_goos_goarchgo><code>zerror_${GOOS}_${GOARCH}.go</code></a></li><li><a href=#zsyscall_goos_goarchgo><code>zsyscall_${GOOS}_${GOARCH}.go</code></a></li><li><a href=#zsysnum_goos_goarchgo><code>zsysnum_${GOOS}_${GOARCH}.go</code></a></li><li><a href=#ztypes_goos_goarchgo><code>ztypes_${GOOS}_${GOARCH}.go</code></a></li></ul></li></ul></nav></div></aside></main></body></html>