<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>5.standard-libraries on Go语言精进之路</title><link>https://golang.coding3min.com/5.standard-library/</link><description>Recent content in 5.standard-libraries on Go语言精进之路</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://golang.coding3min.com/5.standard-library/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://golang.coding3min.com/5.standard-library/5.1-go%E4%BB%A3%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/5.standard-library/5.1-go%E4%BB%A3%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/</guid><description>5.1 Go代码基本标准规范 # 5.1.1 文档 # 不刻意制定详细文档 编码级别文档化，支持一键导出文档 5.1.2 统一的标准和习惯，提高可读性 # 三个统一
统一的日志 统一的接口规范：错误码、返回格式、国际化 统一编码习惯 5.1.3 统一编码习惯 # 变量常量
变量必须见名知义不得用拼音，且长度在 3-20 个字母 名词必须单数 常量必须全大写 所有程序必须有注释
提交记录必须指明 tapd 单号，功能，更新记录
代码文件名
必须见名知义，保证内部代码单一职责 文件夹必须与包名保持一致，全小写，尽量使用短命名，不能使用下划线、中划线等字符 函数
单个函数长度不超过 50 行 参数个数不要超过 5 个（参数过多通常意味着缺少封装，不易维护，容易出错） 函数返回值个数不要超过 3 个，如果超过，建议将其中关系密切的返回值参数封装成一个结构体。 格式化要求 提交代码时，必须使用 gofmt 对代码进行格式化 提交代码时，必须使用 golint 对代码进行检查。 字符串形式的 json 时，使用反单引号，而不是双引号。
&amp;#34;{\&amp;#34;key\&amp;#34;:\&amp;#34;value\&amp;#34;}&amp;#34; 改为格式更清晰的：
` { &amp;#34;key&amp;#34;:&amp;#34;value&amp;#34; } ` 接入自动格式化检查 # 接入自动化代码缺陷扫描 #</description></item><item><title/><link>https://golang.coding3min.com/5.standard-library/5.2-json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/5.standard-library/5.2-json/</guid><description>json处理 # 日常工作中，最常用的数据传输格式就是json，而encoding/json库是内置做解析的库。这一节来看看它的用法，还有几个日常使用中隐晦的陷阱和处理技巧。
json与struct # 一个常见的接口返回内容如下：
{ &amp;#34;data&amp;#34;: { &amp;#34;items&amp;#34;: [ { &amp;#34;_id&amp;#34;: 2 } ], &amp;#34;total_count&amp;#34;: 1 }, &amp;#34;message&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;result_code&amp;#34;: 200 } 在golang中往往是要把json格式转换成结构体对象使用的。 新版Goland粘贴json会自动生成结构体，也可以在 http://json2struct.mervine.net 获得 json 到struct的自动转换。
type ResponseData struct { Data struct { Items []struct { Id int `json:&amp;#34;_id&amp;#34;` } `json:&amp;#34;items&amp;#34;` TotalCount int `json:&amp;#34;total_count&amp;#34;` } `json:&amp;#34;data&amp;#34;` Message string `json:&amp;#34;message&amp;#34;` ResultCode int `json:&amp;#34;result_code&amp;#34;` } 用反斜杠加注解的方式表明属于json中哪个字段，要注意不应该嵌套层数过多，难以阅读容易出错。
一般把内部结构体提出来，可能会另做他用。
type ResponseData struct { Data struct { Items []Body `json:&amp;#34;items&amp;#34;` TotalCount int64 `json:&amp;#34;total_count&amp;#34;` } `json:&amp;#34;data&amp;#34;` Message string `json:&amp;#34;message&amp;#34;` ResultCode int64 `json:&amp;#34;result_code&amp;#34;` } type Body struct { ID int `json:&amp;#34;_id&amp;#34;` } 解析 # 解析就是json字符串，转struct类型。如下，第一个参数为字节数组，第二个为接收的结构体实体地址。如有报错返回错误信息，如没有返回nil。</description></item><item><title/><link>https://golang.coding3min.com/5.standard-library/5.3-go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/5.standard-library/5.3-go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/</guid><description>Go 官方库的文件操作分散在多个包中，比如os、ioutil包，我本来想写一篇总结性的 Go 文件操作的文章，却发现已经有人 2015 年已经写了一篇这样的文章，写的非常好，所以我翻译成了中文，强烈推荐你阅读一下。
原文: Working with Files in Go, 作者: NanoDano
介绍 # 万物皆文件 # UNIX 的一个基础设计就是&amp;quot;万物皆文件&amp;quot;(everything is a file)。我们不必知道一个文件到底映射成什么，操作系统的设备驱动抽象成文件。操作系统为设备提供了文件格式的接口。
Go 语言中的 reader 和 writer 接口也类似。我们只需简单的读写字节，不必知道 reader 的数据来自哪里，也不必知道 writer 将数据发送到哪里。
你可以在/dev下查看可用的设备，有些可能需要较高的权限才能访问。
基本操作 # 创建空文件 # package main import ( &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) var ( newFile *os.File err error ) func main() { newFile, err = os.Create(&amp;#34;test.txt&amp;#34;) if err != nil { log.Fatal(err) } log.</description></item><item><title/><link>https://golang.coding3min.com/5.standard-library/5.4-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/5.standard-library/5.4-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/</guid><description>5.4 命令行应用 # 5.4.1 标准库flag # 一个简单的命令行程序应该可以输出帮助信息，也可以通过传递参数改变程序的配置内容，-h是flag库的默认帮助参数。
./goapi -h Usage of ./goapi: -debug is debug -ip string Input bind address (default &amp;#34;127.0.0.1&amp;#34;) -port int Input bind port (default 80) -version show version information goapi是我build出来的一个二进制go程序，上面所示的四个参数，是自定义的。
按提示的方法，可以像这样使用参数。
./goapi -debug -ip 192.168.1.1 ./goapi -port 8080 ./goapi -version 其中像-version这样的参数是bool类型的参数，只要指定了就会设置为true，不指定时为默认值，假如默认值不是false，想指定为false就要显式的指定。
./goapi -version=false 这几种格式都是兼容的
-isbool #同于 -isbool=true -age=x #-和等号 -age x #-和空格 --age=x #2个-和等号 --age x #2个-和空格 这些参数用flag实现起来很简单，一个参数定义的格式为 flag.XXX(参数名,默认值,提示信息) 返回指针，如下：
var ( showVersion = flag.</description></item><item><title/><link>https://golang.coding3min.com/5.standard-library/%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8Fsort%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/5.standard-library/%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8Fsort%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>golang的sort包提供了部分切片排序的函数和用户自定义数据集的函数。
排序切片 # func Example1() { arry := []int{5,8,3,1,4,2,7,6} fmt.Println(arry) sort.Ints(arry) fmt.Println(arry) // Output: // [5 8 3 1 4 2 7 6] // [1 2 3 4 5 6 7 8] } 排序用户自定义数据集 # type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(&amp;#34;%s: %d&amp;#34;, p.Name, p.Age) } // ByAge implements sort.Interface for []Person based on // the Age field.</description></item></channel></rss>