<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="2.4 map #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/2.func-containers/2.4-map
 2.4.1 映射关系容器 map #  Go语言提供的映射关系容器为 map ， map 使用散列表hash实现。查找复杂度为O(1)，和数组一样，最坏的情况下为O(n),n为元素总数。
这就是Go中map的定义格式。
map[keyType] valueType 注意了，map 是一种引用类型，初值是nil,定义时必须用make来创建，否则会报错
panic: assignment to entry in nil map 必须要申请空间，所有的引用类型都要这么做
var m map[string]string m = make(map[string]string) 当然，也可以这么写
m := make(map[string]string) 2.4.2 使用 #  赋值
m[&#34;name&#34;] = &#34;coding3min&#34; m[&#34;sex&#34;] = &#34;man&#34; 循环遍历
for key := range m { // 原来不用Printf也可以完成拼接输出啊！ 	fmt.Println(&#34;key:&#34;, key, &#34;,value:&#34;, m[key]) } 删除集合元素
delete(m, &#34;name&#34;) PS: 在取值的时候m[key]，假如key不存在，不会报错，会返回value类型的默认值，比如int类型默认值为0"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="2.4 map #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/2.func-containers/2.4-map
 2.4.1 映射关系容器 map #  Go语言提供的映射关系容器为 map ， map 使用散列表hash实现。查找复杂度为O(1)，和数组一样，最坏的情况下为O(n),n为元素总数。
这就是Go中map的定义格式。
map[keyType] valueType 注意了，map 是一种引用类型，初值是nil,定义时必须用make来创建，否则会报错
panic: assignment to entry in nil map 必须要申请空间，所有的引用类型都要这么做
var m map[string]string m = make(map[string]string) 当然，也可以这么写
m := make(map[string]string) 2.4.2 使用 #  赋值
m[&#34;name&#34;] = &#34;coding3min&#34; m[&#34;sex&#34;] = &#34;man&#34; 循环遍历
for key := range m { // 原来不用Printf也可以完成拼接输出啊！ 	fmt.Println(&#34;key:&#34;, key, &#34;,value:&#34;, m[key]) } 删除集合元素
delete(m, &#34;name&#34;) PS: 在取值的时候m[key]，假如key不存在，不会报错，会返回value类型的默认值，比如int类型默认值为0"><meta property="og:type" content="article"><meta property="og:url" content="https://golang.coding3min.com/2.func-containers/2-4-map/"><meta property="article:section" content="2.func-containers"><title>2 4 Map | Go语言精进之路</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.f6567b016e4bd397db60f0b27da9561b3c28d84fb3208aac13e3b7607ee1829d.js integrity="sha256-9lZ7AW5L05fbYPCyfalWGzwo2E+zIIqsE+O3YH7hgp0=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>Go语言精进之路</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://coding3min.com>机智的程序员小熊</a></li><li><a href=https://github.com/minibear2333/>GitHub</a></li><li><a href=/qrcode/>微信公众号</a></li><li><strong>帮助与提示</strong><ul><li><a href=/howtocontribute/>0.0 如何参与贡献</a></li><li><a href=/books-share/>0.1 书籍推荐</a></li></ul></li><li><strong>————基础篇————</strong></li><li><strong>第一章、Go基础</strong><ul><li><a href=/1.base/1-1-install-download/>1.1 安装与下载</a></li><li><a href=/1.base/1-2-hello-world/>1.2 跑起来</a></li><li><a href=/1.base/1-3-go-mod/>1.3 go mod最佳实践</a></li><li><a href=/1.base/1-4-variables/>1.4 变量与常量</a></li><li><a href=/1.base/1-5-switch%E5%92%8Ctypeswitch/>1.5 switch和type switch</a></li><li><a href=/1.base/1-6-for-range/>1.6 循环</a></li><li><a href=/1.base/1-7-range%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/>1.7 range深度解析</a></li></ul></li><li><strong>第二章、函数和容器</strong><ul><li><a href=/2.func-containers/2-1-func/>2.1 函数简单使用和基本知识解析</a></li><li><a href=/2.func-containers/2-2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/>2.2 匿名函数和闭包</a></li><li><a href=/2.func-containers/2-3-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/>2.3 可变参数</a></li><li><a href=/2.func-containers/2-4-map/ class=active>2.4 集合（map）</a></li><li><a href=/2.func-containers/2-5-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/>2.5 数组和切片</a></li></ul></li><li><strong>第三章、语法进阶</strong><ul><li><a href=/3.grammar-advancement/3-1-point/>3.1 指针讨论</a></li><li><a href=/3.grammar-advancement/3-2-struct/>3.2 结构体</a></li><li><a href=/3.grammar-advancement/3-3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/>3.3 接口与多态</a></li><li><a href=/3.grammar-advancement/3-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/>3.4 异常处理</a></li><li>-反射 TODO</li></ul></li><li><strong>第四章、并发和并行</strong><ul><li><a href=/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/>4.1 并发特性</a></li><li><a href=/4.concurrent/4-2-goroutine-wait/>4.2 并发等待</a></li><li><a href=/4.concurrent/4-3-channel/>4.3 channel</a></li><li><a href=/4.concurrent/4-4-deadlock/>4.4 deadlock</a></li><li><a href=/4.concurrent/4-5-select/>4.5 select</a></li><li>-并发安全和锁 TODO</li><li>-原子操作 TODO</li><li>-协程池 TODO</li><li>-消费者生产者框架 TODO</li><li>-GMP调度原理 TODO</li></ul></li><li><strong>————框架篇————</strong></li><li><strong>第五章、标准库</strong><ul><li><a href=5.standard-library/5.1-Go%e4%bb%a3%e7%a0%81%e5%9f%ba%e6%9c%ac%e6%a0%87%e5%87%86%e8%a7%84%e8%8c%83>5.1 Go代码基本标准规范</a></li><li><a href=5.standard-library/5.2-json>5.2 json库</a></li><li><a href=5.standard-library/5.3-Go%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c%e5%a4%a7%e5%85%a8>5.3 文件操作</a></li><li><a href=/5.standard-library/%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8Fsort%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/>5.3 排序</a></li><li><a href=5.standard-library/flag%e5%8c%85%e8%af%bb%e5%8f%96%e5%91%bd%e4%bb%a4%e8%a1%8c%e9%85%8d%e7%bd%ae>5.4 命令行操作</a></li><li>-时间处理 TODO</li><li>-字符串处理 TODO</li><li>-跨平台编译 TODO</li><li>-模板 TODO</li><li>-在线工具系统实战 TODO</li></ul></li><li><strong>第x章、常用开源框架</strong><ul><li>-日志</li><li>-配置管理</li><li>-接口文档</li><li>-错误码控制</li><li>-mysql</li><li>-redis</li><li>-mongo</li><li>rabbitmq</li><li>kafka</li><li>-为开源项目贡献代码</li></ul></li><li><strong>————测试调试篇————</strong></li><li><strong>第x章、调试与测试</strong><ul><li><a href=https://mp.weixin.qq.com/s/ltRpuolYuOa8cXivLZLlUw>单元测试</a></li><li>-基准测试</li><li>-mock</li><li>-自动化测试</li><li>-调试</li></ul></li><li><strong>第x章、性能调优</strong><ul><li>-cpu调度</li><li>-内存管理</li><li>-垃圾回收</li><li>-PProf</li><li>-逃逸分析</li><li>-链路追踪</li></ul></li><li><strong>————网络编程篇————</strong></li><li><strong>第x章、HTTP框架</strong><ul><li>-http库实现GET POST PUT DEL请求</li><li>-websocket实现在线聊天室</li><li>-常用API框架</li><li>-gin框架实现SSO单点登陆系统</li><li>-beego实现博客</li><li>-buffalo实现变更发布系统</li><li>-echo实现工单管理系统</li><li>-Iris实现</li><li>-revel实现</li></ul></li><li><strong>第x章、RPC</strong></li><li><strong>第x章、微服务</strong><ul><li>熔断与限流</li></ul></li><li><strong>第x章、爬虫实战</strong></li><li><strong>第x章、分布式系统</strong><ul><li>-分布式ID生成器</li><li>-分布式锁</li><li>-分布式一致性算法</li><li>-分布式定时任务</li><li>-分布式计算</li></ul></li><li><strong>————工程化篇————</strong></li><li><strong>第x章、Go语言工程化实战</strong><ul><li>构建约束</li><li><a href=/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/golang%E6%89%93%E9%95%9C%E5%83%8Fdockerfile%E7%9A%84%E5%86%99%E6%B3%95/>Go与Dockerfile</a></li></ul></li><li><strong>第x章、Go语言运维实战</strong></li><li><strong>第x章、Go语言监控实战</strong><ul><li>-自监控</li></ul></li><li><strong>————拓展学习————</strong></li><li><strong>第x章、kubernetes开发实战</strong></li><li><strong>第x章、服务治理</strong></li><li><strong>番外1、拓展应用</strong><ul><li><a href=/tools/readme/>小工具</a></li></ul></li><li><strong>番外2、陷阱与缺陷</strong><ul><li><a href=/impossible/range/readme/>range的第二个值实际上是值拷贝</a></li><li><a href=/impossible/%E6%96%B0%E6%89%8B%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>新手常犯的错误</a></li><li><a href=/impossible/%E5%88%9D%E5%AD%A6%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>初学者常犯的错误</a></li><li><a href=/impossible/%E8%BF%9B%E9%98%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>进阶常犯的错误</a></li></ul></li><li><strong>第x章、GO语言版本分析</strong></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>2 4 Map</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#241-映射关系容器-map>2.4.1 映射关系容器 map</a></li><li><a href=#242-使用>2.4.2 使用</a></li><li><a href=#243-map-内部元素的修改>2.4.3 map 内部元素的修改</a></li><li><a href=#244-能够在并发环境中使用的map>2.4.4 能够在并发环境中使用的<code>map</code></a></li><li><a href=#245-小结>2.4.5 小结</a></li></ul></nav></aside></header><article class=markdown><h1 id=24-map>2.4 map
<a class=anchor href=#24-map>#</a></h1><blockquote><p>本节源码位置 <a href=https://github.com/golang-minibear2333/golang/blob/master/2.func-containers/2.4-map>https://github.com/golang-minibear2333/golang/blob/master/2.func-containers/2.4-map</a></p></blockquote><h2 id=241-映射关系容器-map>2.4.1 映射关系容器 map
<a class=anchor href=#241-%e6%98%a0%e5%b0%84%e5%85%b3%e7%b3%bb%e5%ae%b9%e5%99%a8-map>#</a></h2><p><code>Go</code>语言提供的映射关系容器为 <code>map</code> ， <code>map</code> 使用散列表<code>hash</code>实现。查找复杂度为O(1)，和数组一样，最坏的情况下为O(n),n为元素总数。</p><p>这就是<code>Go</code>中<code>map</code>的定义格式。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>keyType</span>] <span style=color:#a6e22e>valueType</span>
</code></pre></div><p>注意了，map 是一种引用类型，初值是<code>nil</code>,定义时必须用<code>make</code>来创建，否则会报错</p><pre><code>panic: assignment to entry in nil map
</code></pre><p>必须要申请空间，所有的引用类型都要这么做</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>m</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>
<span style=color:#a6e22e>m</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>) 
</code></pre></div><p>当然，也可以这么写</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>) 
</code></pre></div><h2 id=242-使用>2.4.2 使用
<a class=anchor href=#242-%e4%bd%bf%e7%94%a8>#</a></h2><p>赋值</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>m</span>[<span style=color:#e6db74>&#34;name&#34;</span>] = <span style=color:#e6db74>&#34;coding3min&#34;</span>
	<span style=color:#a6e22e>m</span>[<span style=color:#e6db74>&#34;sex&#34;</span>] = <span style=color:#e6db74>&#34;man&#34;</span>
</code></pre></div><p>循环遍历</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>m</span> {
    <span style=color:#75715e>// 原来不用Printf也可以完成拼接输出啊！
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;key:&#34;</span>, <span style=color:#a6e22e>key</span>, <span style=color:#e6db74>&#34;,value:&#34;</span>, <span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>key</span>]) 
}
</code></pre></div><p>删除集合元素</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	delete(<span style=color:#a6e22e>m</span>, <span style=color:#e6db74>&#34;name&#34;</span>)
</code></pre></div><p>PS: 在取值的时候<code>m[key]</code>，假如<code>key</code>不存在，不会报错，会返回<code>value</code>类型的默认值，比如<code>int</code>类型默认值为<code>0</code></p><p>当然了，如果你想明确的知道元素是否存在，如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>key</span>]; <span style=color:#a6e22e>ok</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>key</span>, <span style=color:#e6db74>&#34;存在，值为：&#34;</span>, <span style=color:#a6e22e>value</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>key</span>, <span style=color:#e6db74>&#34; 不存在&#34;</span>)
	}
</code></pre></div><h2 id=243-map-内部元素的修改>2.4.3 map 内部元素的修改
<a class=anchor href=#243-map-%e5%86%85%e9%83%a8%e5%85%83%e7%b4%a0%e7%9a%84%e4%bf%ae%e6%94%b9>#</a></h2><p>map 可以拷贝吗？</p><p><code>map</code> 其实是不能拷贝的，如果想要拷贝一个 <code>map</code> ，只有一种办法就是循环赋值，就像这样</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>originalMap</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)
<span style=color:#a6e22e>originalMap</span>[<span style=color:#e6db74>&#34;one&#34;</span>] = <span style=color:#ae81ff>1</span>
<span style=color:#a6e22e>originalMap</span>[<span style=color:#e6db74>&#34;two&#34;</span>] = <span style=color:#ae81ff>2</span>

<span style=color:#75715e>// Create the target map
</span><span style=color:#75715e></span><span style=color:#a6e22e>targetMap</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)

<span style=color:#75715e>// Copy from the original map to the target map
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>originalMap</span> {
    <span style=color:#a6e22e>targetMap</span>[<span style=color:#a6e22e>key</span>] = <span style=color:#a6e22e>value</span>
}
</code></pre></div><p>如果 <code>map</code> 中有指针，还要考虑深拷贝的过程</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>originalMap</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>num</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>1</span>
<span style=color:#a6e22e>originalMap</span>[<span style=color:#e6db74>&#34;one&#34;</span>] = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>num</span>

<span style=color:#75715e>// Create the target map
</span><span style=color:#75715e></span><span style=color:#a6e22e>targetMap</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)

<span style=color:#75715e>// Copy from the original map to the target map
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>originalMap</span> {
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>tmpNum</span> <span style=color:#66d9ef>int</span> = <span style=color:#f92672>*</span><span style=color:#a6e22e>value</span>
    <span style=color:#a6e22e>targetMap</span>[<span style=color:#a6e22e>key</span>] = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>tmpNum</span>
}
</code></pre></div><p>如果想要更新 <code>map</code> 中的<code>value</code>，可以通过赋值来进行操作</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>map</span>[<span style=color:#e6db74>&#34;one&#34;</span>] = <span style=color:#ae81ff>1</span>
</code></pre></div><p>但如果 <code>value</code> 是一个结构体，可以直接替换结构体，但无法更新结构体内部的值</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>originalMap</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>Person</span>)
<span style=color:#a6e22e>originalMap</span>[<span style=color:#e6db74>&#34;minibear2333&#34;</span>] = <span style=color:#a6e22e>Person</span>{<span style=color:#a6e22e>age</span>: <span style=color:#ae81ff>26</span>}
<span style=color:#a6e22e>originalMap</span>[<span style=color:#e6db74>&#34;minibear2333&#34;</span>].<span style=color:#a6e22e>age</span> = <span style=color:#ae81ff>5</span>
</code></pre></div><p>你可以
<a href=https://github.com/golang-minibear2333/golang/blob/master/2.func-containers/2.4-map/map1.go#L89>试下源码函数 updateMapValue</a> ，会报这个错误</p><blockquote><p>Cannot assign to originalMap[&ldquo;minibear2333&rdquo;].age</p></blockquote><p>问题链接
<a href=https://github.com/golang/go/issues/3117>issue-3117</a> , 其中
<a href=https://github.com/golang/go/issues/3117#issuecomment-430632750>ianlancetaylor</a> 的回答很好的解释了这一点</p><p>简单来说就是map不是一个并发安全的结构，所以，并不能修改他在结构体中的值。</p><p>这如果目前的形式不能修改的话，就面临两种选择，</p><ul><li>1.修改原来的设计;</li><li>2.想办法让map中的成员变量可以修改，</li></ul><p>因为懒得该这个结构体，就选择了方法2</p><p>要么创建个临时变量，做拷贝，像这样</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>tmp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#e6db74>&#34;foo&#34;</span>]
<span style=color:#a6e22e>tmp</span>.<span style=color:#a6e22e>x</span> = <span style=color:#ae81ff>4</span>
<span style=color:#a6e22e>m</span>[<span style=color:#e6db74>&#34;foo&#34;</span>] = <span style=color:#a6e22e>tmp</span>
</code></pre></div><p>要么直接用指针，比较方便</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>originalPointMap</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>Person</span>)
<span style=color:#a6e22e>originalPointMap</span>[<span style=color:#e6db74>&#34;minibear2333&#34;</span>] = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Person</span>{<span style=color:#a6e22e>age</span>: <span style=color:#ae81ff>26</span>}
<span style=color:#a6e22e>originalPointMap</span>[<span style=color:#e6db74>&#34;minibear2333&#34;</span>].<span style=color:#a6e22e>age</span> = <span style=color:#ae81ff>5</span>
</code></pre></div><h2 id=244-能够在并发环境中使用的map>2.4.4 能够在并发环境中使用的<code>map</code>
<a class=anchor href=#244-%e8%83%bd%e5%a4%9f%e5%9c%a8%e5%b9%b6%e5%8f%91%e7%8e%af%e5%a2%83%e4%b8%ad%e4%bd%bf%e7%94%a8%e7%9a%84map>#</a></h2><p><code>Go</code>中的<code>map</code>在并发读的时候没问题，但是并发写就不行了（线程不安全），会发生竞态问题。</p><p>所以有一个叫<code>sync.Map</code>的封装数据结构供大家使用，简单用法如下：
定义和存储</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>scene</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Map</span>
	<span style=color:#a6e22e>scene</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;coding3min&#34;</span>)
	<span style=color:#a6e22e>scene</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#e6db74>&#34;age&#34;</span>, <span style=color:#ae81ff>11</span>)
</code></pre></div><p>取值</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>scene</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#e6db74>&#34;name&#34;</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>v</span>)
	}
	<span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> = <span style=color:#a6e22e>scene</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#e6db74>&#34;age&#34;</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>v</span>)
	}
</code></pre></div><p>输出</p><pre><code>coding3min
11
</code></pre><p>删除和遍历,这里遍历就用到了
<a href=https://mp.weixin.qq.com/s/HsaEjO9TgUcfrBhaMS0C5A>函数当作参数传递</a> 和
<a href=https://mp.weixin.qq.com/s/YRD2-4oO9ENHD3ADYlvsCg>匿名函数</a> 的知识。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>scene</span>.<span style=color:#a6e22e>Delete</span>(<span style=color:#e6db74>&#34;age&#34;</span>)

	<span style=color:#a6e22e>scene</span>.<span style=color:#a6e22e>Range</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>bool</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;key:&#34;</span>,<span style=color:#a6e22e>key</span>,<span style=color:#e6db74>&#34;,value:&#34;</span>,<span style=color:#a6e22e>value</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
	})
</code></pre></div><h2 id=245-小结>2.4.5 小结
<a class=anchor href=#245-%e5%b0%8f%e7%bb%93>#</a></h2><p>本节介绍了字典<code>map</code>类型，这种类型在很多语言中都有，并且学习了它的增加删除元素的方法，以及更新value要注意的点。</p><p>还介绍了并发环境下使用的线程安全的 <code>sync.Map</code>。</p></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=minibear2333/blog-comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/golang-minibear2333/golang/edit/master/./2.func-containers/2-4-map.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#241-映射关系容器-map>2.4.1 映射关系容器 map</a></li><li><a href=#242-使用>2.4.2 使用</a></li><li><a href=#243-map-内部元素的修改>2.4.3 map 内部元素的修改</a></li><li><a href=#244-能够在并发环境中使用的map>2.4.4 能够在并发环境中使用的<code>map</code></a></li><li><a href=#245-小结>2.4.5 小结</a></li></ul></nav></div></aside></main></body></html>