<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>4.concurrents on Go语言精进之路</title><link>https://golang.coding3min.com/4.concurrent/</link><description>Recent content in 4.concurrents on Go语言精进之路</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://golang.coding3min.com/4.concurrent/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://golang.coding3min.com/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/</guid><description>4.1 go 语言中的并发特性 # 本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/4.concurrent/4.1-goroutine/
以前我们写并发的程序一般是用多线程来实现，自己维护一个线程池，在恰当的时候创建、销毁、分配资源。
go 在并发方面为我们提供了一个语言级别的支持， goroutine 和 channel 相互配合，这决定了他的先天优势。
goroutine 也就是go协程，概念类似于线程， Go 程序运行时会自动调度和管理，系统能智能地将 goroutine 中的任务合理地分配给 CPU , 让这些任务尽量并发运作。
这里说并发其实是不严谨的，只不过我们习惯了说并发，延展阅读见 goroutine是并行还是并发？
4.1.1 他和线程对比 # 从使用上讲
比线程更轻量级，可以创建十万、百万不用担心资源问题。 和 channel 搭配使用，实现高并发， goroutine 之间传输数据更方便。 如果访问同一个数据块，要小心数据竞态问题、共享锁还是互斥锁的选择问题、并发操作的数据同步问题（后面会说） 从其实现上讲
从资源上讲，线程的栈内存大小一般是固定的一般为 2MB ，虽然这个数值可以设置，但是 太大了浪费，太小了容易不够用, 而 goroutine 栈内存是可变的，初始一般为 2KB ，随着需求可以扩大达到 1GB。 所以 goroutine 十分的轻量级，且能满足不同的需求。 从调度上讲，线程的调度由 OS 的内核完成；线程的切换需要 CPU 寄存器 和 内存的数据交换 ，从而切换不同的线程上下文。 其触发方式为 CPU时钟 , 而 goroutine 的调度则比较轻量级，由自身的调度器完成。 协程同线程的关系，有些类似于 线程同进程的关系。 4.</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-2-goroutine-wait/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-2-goroutine-wait/</guid><description>4.2 并发等待 # 本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/4.concurrent/4.2-goroutine-wait/
4.2.1 简介 # goroutine 是 Golang 中非常有用的功能，有时候 goroutine 没执行完函数就返回了，如果希望等待当前的 goroutine 执行完成再接着往下执行，该怎么办？
func say(s string) { for i := 0; i &amp;lt; 3; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&amp;#34;hello world&amp;#34;) fmt.Println(&amp;#34;over!&amp;#34;) } 输出 over！ , 主线程没有等待
4.2.2 使用 Sleep 等待 # func main() { go say(&amp;#34;hello world&amp;#34;) time.Sleep(time.Second*1) fmt.Println(&amp;#34;over!&amp;#34;) } 运行修改后的程序，结果如下：
hello world hello world hello world over!</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-3-channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-3-channel/</guid><description>4.3 channel # 到这里你正在接触最核心和重要的知识！认真学习的你很棒！
本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/4.concurrent/4.3-channel/
4.3.1 什么是 channel # Go 是一门从语言级别就支持并发的编程语言， 它有一个设计哲学很特别 不要通过共享内存来通信，而应通过通信来共享内存 ，听起来是有一点绕。
在传统语言中并发使用全局变量来进行不同线程之间的数据共享，这种方式就是使用共享内存的方式进行通信。而 Go 会在协程和协程之间打一个隧道，通过这个隧道来传输数据（发送和接收）。
打个比方，我们平时肯定没少接触过队列，队列的特点是先进先出，多方生产插入，多方消费接收。这个队列/隧道就是channel。
channel 是 goroutine 之间互相通讯的东西，goroutine 之间用来发消息和接收消息。其实，就是在做 goroutine 之间的内存共享。
我们来看看具体是什么使用的。
4.3.2 声明与初始化 # channel是类型相关的，也就是说一个 channel 只能传递一种类型的值，这个类型需要在 channel 声明时指定。
channel 的一般声明形式：
var chanName chan 类型 与普通变量的声明不同的是在类型前面加了 channel 关键字，类型 则指定了这个 channel 所能传递的元素类型。示例：
var a chan int //声明一个传递元素类型为int的channel var b chan float64 var c chan string 通道是一个引用类型，初始值为nil，对于值为nil的通道，不论具体是什么类型，它们所属的接收和发送操作都会永久处于阻塞状态。
所以必须手动make初始化，示例：
a := make(chan int) //初始化一个int型的名为a的channel b := make(chan float64) c := make(chan string) 既然是队列，那就有大小，上面没声明具体的大小，被认为是无缓冲的（注意大小是 0，不是 1）也就是说必须有其他goroutine接收，不然就会阻塞在那。声明有缓冲的，指定大小就可以了。</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-4-deadlock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-4-deadlock/</guid><description>4.4 deadlock # 本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/4.concurrent/4.4-deadlock/
4.4.1 什么时候会导致死锁 # 在计算机组成原理里说过 死锁有三个必要条件他们分别是 循环等待、资源共享、非抢占式，在并发中出现通道死锁只有两种情况：
数据要发送，但是没有人接收 数据要接收，但是没有人发送 4.4.2 发送单个值时的死锁 # 牢记这两点问题就很清晰了，复习下之前的例子，会死锁
a := make(chan int) a &amp;lt;- 1 //将数据写入channel z := &amp;lt;-a //从channel中读取数据 有且只有一个协程时，无缓冲的通道 先发送会阻塞在发送，先接收会阻塞在接收处。 发送操作在接收者准备好之前是阻塞的，接收操作在发送之前是阻塞的， 解决办法就是改为缓冲通道，或者使用协程配对 解决方法一,协程配对，先发送还是先接收无所谓只要配对就好
chanInt := make(chan int) go func() { chanInt &amp;lt;- 1 }() res := &amp;lt;-chanInt 解决方法二，缓冲通道
chanInt := make(chan int,1) chanInt &amp;lt;- 2 res := &amp;lt;-chanInt 缓冲通道内部的消息数量用len()函数可以测试出来 缓冲通道的容量可以用cap()测试出来 在满足cap&amp;gt;len时候，因为没有满，发送不会阻塞 在len&amp;gt;0时，因为不为空，所以接收不会阻塞 使用缓冲通道可以让生产者和消费者减少阻塞的可能性，对异步操作更友好，不用等待对方准备，但是容量不应设置过大，不然会占用较多内存。</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-5-select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-5-select/</guid><description>4.5 select # 本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/4.concurrent/4.5-select
4.5.1 select与switch # 让我们来复习一下switch语句，在switch语句中，会逐个匹配case语句(可以是值也可以是表达式)，一个一个的判断过去，直到有符合的语句存在，执行匹配的语句内容后跳出switch。
func demo(number int){ switch{ case number &amp;gt;= 90: fmt.Println(&amp;#34;优秀&amp;#34;) default: fmt.Println(&amp;#34;太搓了&amp;#34;) } } 而 select 用于处理通道，它的语法与 switch 非常类似。每个 case 语句里必须是一个 channel 操作。它既可以用于 channel 的数据接收，也可以用于 channel 的数据发送。
func foo() { chanInt := make(chan int) defer close(chanInt) go func() { select { case data, ok := &amp;lt;-chanInt: if ok { fmt.Println(data) } default: fmt.Println(&amp;#34;全部阻塞&amp;#34;) } }() time.Sleep(time.Second) chanInt &amp;lt;- 1 } 输出1</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-6-cron/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-6-cron/</guid><description>4.6 定时器 # 本节源码位置 https://github.com/golang-minibear2333/golang/tree/master/4.concurrent/4.6-cron
很多时候需要周期性的执行某些操作，就需要用到定时器。定时器有三种思路。
4.6.1 Sleep # 使用休眠，让当前Goroutine休眠一定的时间来实现定时的效果，缺点是程序执行速度不均匀，导致定时周期不均匀。
for{ fmt.Println(time.Now()) time.Sleep(time.Second*1) } 4.6.2 Timer # Go 语言的内置包，指定一个时间开始计时，时间到之后会向外发送通知，发送通知的方式就是使用&amp;lt;-chan Time 返回内容。
第一种方式，直接在需要等待处使用，效果和Sleep一样，一使用就卡在那了内部就是使用了Timer。
fmt.Println(time.Now()) &amp;lt;-time.After(1*time.Second) fmt.Println(time.Now()) 也可以把他拆分开，在任意地方进行等待
timer := time.NewTimer(1 * time.Second) &amp;lt;-timer.C fmt.Println(time.Now()) 但是以上只是做到延迟一次性执行，我们来改造一下，把他变成定时器。
done := make(chan struct{}) timer := time.NewTimer(1 * time.Second) go func () { for { select { case &amp;lt;-timer.C: fmt.Println(time.Now()) timer.Reset(1 * time.Second) case &amp;lt;-done: return } } }() &amp;lt;-time.After(5*time.Second + time.</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-7-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-7-lock/</guid><description>4.7 并发安全与锁 # 本节源码位置 https://github.com/golang-minibear2333/golang/tree/master/4.concurrent/4.7-lock/
并发安全，就是多个并发体在同一段时间内访问同一个共享数据,共享数据能被正确处理。
很多语言的并发编程很容易在同时修改某个变量的时候，因为操作不是原子的，而出现错误计算，比如一个加法运算使用中的变量被修改，而导致计算结果出错，典型的像统计商品库存。
个人建议只要涉及到共享变量统统使用channel，因为channel源码中使用了互斥锁，它是并发安全的。
我们可以不用，但不可以不了解，手中有粮心中不慌。
4.7.1 并发不安全的例子 # 数组是并发不安全的，在例子开始前我们要知道append函数的行为：长度足够在原数组cap内追加函数，增加len，长度不够则触发扩容，申请新数组cap增加一倍，赋值迁移。
所以在这个过程中，仅讨论扩容操作的话可能存在同时申请并赋值的情况，导致漏掉某次扩容增加的数据。
var s []int func appendValue(i int) { s = append(s, i) } func main() { for i := 0; i &amp;lt; 10000; i++ { //10000个协程同时添加切片 go appendValue(i) } time.Sleep(2) fmt.Println(len(s)) } 比如上例，10000 个协程同时为切片增加数据，你可以尝试运行一下，打印出来的一定不是 10000 。
以上并发操作的同一个资源，专业名词叫做临界区。 因为并发操作存在数据竞争，导致数据值意外改写，最后的结果与期待的不符，这种问题统称为竞态问题。 常见于控制商品减库存，控制余额增减等情况。 那么有什么办法解决竞态问题呢？
互斥锁：让访问某个临界区的时候，只有一个 goroutine 可以访问。 原子操作：让某些操作变成原子的，这个后续讨论。 这两个思路贯穿了无数的高并发/分布式方案，区别是在一个进程应用中使用，还是借助某些第三方手段来实现，比如中间件。独孤九剑森罗万象一定要牢牢记住。
4.7.2 互斥锁 # Go 语言中互斥锁的用法如下：</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-8-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-8-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid><description>4.8 原子操作 # 本节源码位置 https://github.com/golang-minibear2333/golang/tree/master/4.concurrent/4.8-atomic/
代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic 提供。
大多数情况下我们都是针对基本数据类型进行数据操作，能不加锁就不加锁。
首先很多人都不相信基本类型并发修改会出现竞态问题。不妨尝试一下，并发加一。
var wg sync.WaitGroup for i := 0; i &amp;lt; 10000; i++ { wg.Add(1) go func () { defer wg.Done() xInt32++ }() } wg.Wait() print(xInt32) 无论输出多少次都无法达到10000,之所以如此就是因为此处的加1操作并不是原子的，都是先取当前值，加1，再赋值，会出现覆盖的情况。
4.8.1 修改 # 修改是最常用到的。
func modify(delta int32) { atomic.AddInt32(&amp;amp;xInt32, delta) atomic.AddInt64(&amp;amp;xInt64, int64(delta)) atomic.AddUint32(&amp;amp;xuInt32, uint32(delta)) atomic.AddUint64(&amp;amp;xuInt64, uint64(delta)) } 我们忽略了Uintptr的讨论，这是内存地址的整数表示，是用来存地址内容的，暂时没有遇到过指针的数据计算。
var wg sync.WaitGroup for i := 0; i &amp;lt; 10000; i++ { wg.Add(1) go func () { defer wg.</description></item><item><title/><link>https://golang.coding3min.com/4.concurrent/4-9-sync/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://golang.coding3min.com/4.concurrent/4-9-sync/</guid><description>4.9 sync包 # 本节源码位置 https://github.com/golang-minibear2333/golang/tree/master/4.concurrent/4.9-sync/
4.9.1 sync.Map 并发安全的Map # 反例如下，两个Goroutine分别读写。
func unsafeMap(){ var wg sync.WaitGroup m := make(map[int]int) wg.Add(2) go func() { defer wg.Done() for i := 0; i &amp;lt; 10000; i++ { m[i] = i } }() go func() { defer wg.Done() for i := 0; i &amp;lt; 10000; i++ { fmt.Println(m[i]) } }() wg.Wait() } 执行报错：
0 fatal error: concurrent map read and map write goroutine 7 [running]: runtime.</description></item></channel></rss>