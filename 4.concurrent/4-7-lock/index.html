<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="4.7 并发安全与锁 #   本节源码位置 https://github.com/golang-minibear2333/golang/tree/master/4.concurrent/4.7-lock/
  并发安全，就是多个并发体在同一段时间内访问同一个共享数据,共享数据能被正确处理。
 很多语言的并发编程很容易在同时修改某个变量的时候，因为操作不是原子的，而出现错误计算，比如一个加法运算使用中的变量被修改，而导致计算结果出错，典型的像统计商品库存。
个人建议只要涉及到共享变量统统使用channel，因为channel源码中使用了互斥锁，它是并发安全的。
我们可以不用，但不可以不了解，手中有粮心中不慌。
4.7.1 并发不安全的例子 #  数组是并发不安全的，在例子开始前我们要知道append函数的行为：长度足够在原数组cap内追加函数，增加len，长度不够则触发扩容，申请新数组cap增加一倍，赋值迁移。
所以在这个过程中，仅讨论扩容操作的话可能存在同时申请并赋值的情况，导致漏掉某次扩容增加的数据。
var s []int func appendValue(i int) { s = append(s, i) } func main() { for i := 0; i < 10000; i++ { //10000个协程同时添加切片 	go appendValue(i) } time.Sleep(2) fmt.Println(len(s)) } 比如上例，10000 个协程同时为切片增加数据，你可以尝试运行一下，打印出来的一定不是 10000 。
 以上并发操作的同一个资源，专业名词叫做临界区。 因为并发操作存在数据竞争，导致数据值意外改写，最后的结果与期待的不符，这种问题统称为竞态问题。  常见于控制商品减库存，控制余额增减等情况。 那么有什么办法解决竞态问题呢？
 互斥锁：让访问某个临界区的时候，只有一个 goroutine 可以访问。 原子操作：让某些操作变成原子的，这个后续讨论。  这两个思路贯穿了无数的高并发/分布式方案，区别是在一个进程应用中使用，还是借助某些第三方手段来实现，比如中间件。独孤九剑森罗万象一定要牢牢记住。
4.7.2 互斥锁 #  Go 语言中互斥锁的用法如下："><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="4.7 并发安全与锁 #   本节源码位置 https://github.com/golang-minibear2333/golang/tree/master/4.concurrent/4.7-lock/
  并发安全，就是多个并发体在同一段时间内访问同一个共享数据,共享数据能被正确处理。
 很多语言的并发编程很容易在同时修改某个变量的时候，因为操作不是原子的，而出现错误计算，比如一个加法运算使用中的变量被修改，而导致计算结果出错，典型的像统计商品库存。
个人建议只要涉及到共享变量统统使用channel，因为channel源码中使用了互斥锁，它是并发安全的。
我们可以不用，但不可以不了解，手中有粮心中不慌。
4.7.1 并发不安全的例子 #  数组是并发不安全的，在例子开始前我们要知道append函数的行为：长度足够在原数组cap内追加函数，增加len，长度不够则触发扩容，申请新数组cap增加一倍，赋值迁移。
所以在这个过程中，仅讨论扩容操作的话可能存在同时申请并赋值的情况，导致漏掉某次扩容增加的数据。
var s []int func appendValue(i int) { s = append(s, i) } func main() { for i := 0; i < 10000; i++ { //10000个协程同时添加切片 	go appendValue(i) } time.Sleep(2) fmt.Println(len(s)) } 比如上例，10000 个协程同时为切片增加数据，你可以尝试运行一下，打印出来的一定不是 10000 。
 以上并发操作的同一个资源，专业名词叫做临界区。 因为并发操作存在数据竞争，导致数据值意外改写，最后的结果与期待的不符，这种问题统称为竞态问题。  常见于控制商品减库存，控制余额增减等情况。 那么有什么办法解决竞态问题呢？
 互斥锁：让访问某个临界区的时候，只有一个 goroutine 可以访问。 原子操作：让某些操作变成原子的，这个后续讨论。  这两个思路贯穿了无数的高并发/分布式方案，区别是在一个进程应用中使用，还是借助某些第三方手段来实现，比如中间件。独孤九剑森罗万象一定要牢牢记住。
4.7.2 互斥锁 #  Go 语言中互斥锁的用法如下："><meta property="og:type" content="article"><meta property="og:url" content="https://golang.coding3min.com/4.concurrent/4-7-lock/"><meta property="article:section" content="4.concurrent"><title>4 7 Lock | Go语言精进之路</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.138d5d290555f72e9dd07151e5d97c083e43b3709dc2bef9c7e32ab4e1ddb560.js integrity="sha256-E41dKQVV9y6d0HFR5dl8CD5Ds3Cdwr75x+MqtOHdtWA=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>Go语言精进之路</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://coding3min.com>机智的程序员小熊</a></li><li><a href=https://github.com/minibear2333/>GitHub</a></li><li><a href=/qrcode/>微信公众号</a></li><li><strong>帮助与提示</strong><ul><li><a href=/howtocontribute/>0.0 如何参与贡献</a></li><li><a href=/books-share/>0.1 书籍推荐</a></li></ul></li><li><strong>————基础篇————</strong></li><li><strong>第一章、Go基础</strong><ul><li><a href=/1.base/1-1-install-download/>1.1 安装与下载</a></li><li><a href=/1.base/1-2-hello-world/>1.2 跑起来</a></li><li><a href=/1.base/1-3-go-mod/>1.3 go mod最佳实践</a></li><li><a href=/1.base/1-4-variables/>1.4 变量与常量</a></li><li><a href=/1.base/1-5-switch%E5%92%8Ctypeswitch/>1.5 switch和type switch</a></li><li><a href=/1.base/1-6-for-range/>1.6 循环</a></li><li><a href=/1.base/1-7-range%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/>1.7 range深度解析</a></li></ul></li><li><strong>第二章、函数和容器</strong><ul><li><a href=/2.func-containers/2-1-func/>2.1 函数简单使用和基本知识解析</a></li><li><a href=/2.func-containers/2-2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/>2.2 匿名函数和闭包</a></li><li><a href=/2.func-containers/2-3-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/>2.3 可变参数</a></li><li><a href=/2.func-containers/2-4-map/>2.4 集合（map）</a></li><li><a href=/2.func-containers/2-5-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/>2.5 数组和切片</a></li></ul></li><li><strong>第三章、语法进阶</strong><ul><li><a href=/3.grammar-advancement/3-1-point/>3.1 指针讨论</a></li><li><a href=/3.grammar-advancement/3-2-struct/>3.2 结构体</a></li><li><a href=/3.grammar-advancement/3-3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/>3.3 接口与多态</a></li><li><a href=/3.grammar-advancement/3-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/>3.4 异常处理</a></li><li>-反射 TODO</li></ul></li><li><strong>第四章、并发和并行</strong><ul><li><a href=/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/>4.1 并发特性</a></li><li><a href=/4.concurrent/4-2-goroutine-wait/>4.2 并发等待</a></li><li><a href=/4.concurrent/4-3-channel/>4.3 channel</a></li><li><a href=/4.concurrent/4-4-deadlock/>4.4 deadlock</a></li><li><a href=/4.concurrent/4-5-select/>4.5 select</a></li><li><a href=/4.concurrent/4-6-cron/>4.6 定时器</a></li><li><a href=/4.concurrent/4-7-lock/ class=active>4.7 并发安全和锁</a></li><li><a href=/4.concurrent/4-8-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/>4.8 原子操作</a></li><li><a href=/4.concurrent/4-9-sync/>4.9 sync包</a></li><li>-协程池 TODO</li><li>-GMP调度原理 TODO</li></ul></li><li><strong>————框架篇————</strong></li><li><strong>第五章、常用标准库</strong><ul><li><a href=5.standard-library/5.1-Go%e4%bb%a3%e7%a0%81%e5%9f%ba%e6%9c%ac%e6%a0%87%e5%87%86%e8%a7%84%e8%8c%83>5.1 Go代码基本标准规范</a></li><li><a href=5.standard-library/5.2-json>5.2 json库</a></li><li><a href=5.standard-library/5.3-Go%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c%e5%a4%a7%e5%85%a8>5.3 文件操作</a></li><li><a href=/5.standard-library/%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8Fsort%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/>5.3 排序</a></li><li><a href=5.standard-library/flag%e5%8c%85%e8%af%bb%e5%8f%96%e5%91%bd%e4%bb%a4%e8%a1%8c%e9%85%8d%e7%bd%ae>5.4 命令行操作</a></li><li>-时间处理 TODO</li><li>-字符串处理 TODO</li><li>-跨平台编译 TODO</li><li>-模板 TODO</li><li>-在线工具系统实战 TODO</li></ul></li><li><strong>第x章、常用数据操作</strong><ul><li>-mysql</li><li>-redis</li><li>-mongo</li><li>-rabbitmq</li><li>-kafka</li><li>-etcd</li><li>-rabbitmq</li><li>-zookeeper</li><li>-ElasticSearch</li></ul></li><li><strong>第x章、常用第三方包</strong><ul><li>-日志</li><li>-配置管理</li><li>-接口文档</li><li>-错误码控制</li></ul></li><li><strong>————测试调试篇————</strong></li><li><strong>第x章、调试与测试</strong><ul><li><a href=https://mp.weixin.qq.com/s/ltRpuolYuOa8cXivLZLlUw>单元测试</a></li><li>-基准测试</li><li>-mock</li><li>-自动化测试</li><li>-调试</li></ul></li><li><strong>第x章、性能调优</strong><ul><li>-cpu调度</li><li>-内存管理</li><li>-垃圾回收</li><li>-PProf</li><li>-逃逸分析</li><li>-链路追踪</li></ul></li><li><strong>————网络编程篇————</strong></li><li><strong>第x章、HTTP框架</strong><ul><li>-http库实现GET POST PUT DEL请求</li><li>-websocket实现在线聊天室</li><li>-常用API框架</li><li>-gin框架实现SSO单点登陆系统</li><li>-beego实现博客</li><li>-buffalo实现变更发布系统</li><li>-echo实现工单管理系统</li><li>-Iris实现</li><li>-revel实现</li></ul></li><li><strong>第x章、RPC</strong></li><li><strong>第x章、微服务</strong><ul><li>熔断与限流</li></ul></li><li><strong>第x章、爬虫实战</strong></li><li><strong>第x章、分布式系统</strong><ul><li>-分布式ID生成器</li><li>-分布式锁</li><li>-分布式一致性算法</li><li>-分布式定时任务</li><li>-分布式计算</li></ul></li><li><strong>————工程化篇————</strong></li><li><strong>第x章、Go语言工程化实战</strong><ul><li>构建约束</li><li><a href=/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/golang%E6%89%93%E9%95%9C%E5%83%8Fdockerfile%E7%9A%84%E5%86%99%E6%B3%95/>Go与Dockerfile</a></li></ul></li><li><strong>第x章、Go语言运维实战</strong></li><li><strong>第x章、Go语言监控实战</strong><ul><li>-自监控</li></ul></li><li><strong>————拓展学习————</strong></li><li><strong>第x章、kubernetes开发实战</strong></li><li><strong>第x章、服务治理</strong></li><li><strong>番外1、拓展应用</strong><ul><li><a href=/tools/readme/>小工具</a></li></ul></li><li><strong>番外2、陷阱与缺陷</strong><ul><li><a href=/impossible/range/readme/>range的第二个值实际上是值拷贝</a></li><li><a href=/impossible/%E6%96%B0%E6%89%8B%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>新手常犯的错误</a></li><li><a href=/impossible/%E5%88%9D%E5%AD%A6%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>初学者常犯的错误</a></li><li><a href=/impossible/%E8%BF%9B%E9%98%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/>进阶常犯的错误</a></li></ul></li><li><strong>第x章、GO语言版本分析</strong></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>4 7 Lock</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#471-并发不安全的例子>4.7.1 并发不安全的例子</a></li><li><a href=#472-互斥锁>4.7.2 互斥锁</a></li><li><a href=#473-读写锁>4.7.3 读写锁</a></li><li><a href=#474-小结>4.7.4 小结</a></li><li><a href=#引用>引用</a></li></ul></nav></aside></header><article class=markdown><h1 id=47-并发安全与锁>4.7 并发安全与锁
<a class=anchor href=#47-%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8%e4%b8%8e%e9%94%81>#</a></h1><blockquote><p>本节源码位置 <a href=https://github.com/golang-minibear2333/golang/tree/master/4.concurrent/4.7-lock/>https://github.com/golang-minibear2333/golang/tree/master/4.concurrent/4.7-lock/</a></p></blockquote><blockquote><p>并发安全，就是多个并发体在同一段时间内访问同一个共享数据,共享数据能被正确处理。</p></blockquote><p>很多语言的并发编程很容易在同时修改某个变量的时候，因为操作不是原子的，而出现错误计算，比如一个加法运算使用中的变量被修改，而导致计算结果出错，典型的像统计商品库存。</p><p>个人建议只要涉及到共享变量统统使用<code>channel</code>，因为<code>channel</code>源码中使用了互斥锁，它是并发安全的。</p><p>我们可以不用，但不可以不了解，手中有粮心中不慌。</p><h2 id=471-并发不安全的例子>4.7.1 并发不安全的例子
<a class=anchor href=#471-%e5%b9%b6%e5%8f%91%e4%b8%8d%e5%ae%89%e5%85%a8%e7%9a%84%e4%be%8b%e5%ad%90>#</a></h2><p>数组是并发不安全的，在例子开始前我们要知道<code>append</code>函数的行为：长度足够在原数组<code>cap</code>内追加函数，增加<code>len</code>，长度不够则触发扩容，申请新数组<code>cap</code>增加一倍，赋值迁移。</p><p>所以在这个过程中，仅讨论扩容操作的话可能存在同时申请并赋值的情况，导致漏掉某次扩容增加的数据。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s</span> []<span style=color:#66d9ef>int</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>appendValue</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>s</span> = append(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>i</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> { <span style=color:#75715e>//10000个协程同时添加切片
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>appendValue</span>(<span style=color:#a6e22e>i</span>)
	}
    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>2</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(len(<span style=color:#a6e22e>s</span>))
}
</code></pre></div><p>比如上例，<code>10000</code> 个协程同时为切片增加数据，你可以尝试运行一下，打印出来的一定不是 <code>10000</code> 。</p><ul><li>以上并发操作的同一个资源，专业名词叫做<strong>临界区</strong>。</li><li>因为并发操作存在数据竞争，导致数据值意外改写，最后的结果与期待的不符，这种问题统称为<strong>竞态问题</strong>。</li></ul><p>常见于控制商品减库存，控制余额增减等情况。 那么有什么办法解决竞态问题呢？</p><ul><li>互斥锁：让访问某个临界区的时候，只有一个 <code>goroutine</code> 可以访问。</li><li>原子操作：让某些操作变成原子的，这个后续讨论。</li></ul><p>这两个思路贯穿了无数的高并发/分布式方案，区别是在一个进程应用中使用，还是借助某些第三方手段来实现，比如中间件。独孤九剑森罗万象一定要牢牢记住。</p><h2 id=472-互斥锁>4.7.2 互斥锁
<a class=anchor href=#472-%e4%ba%92%e6%96%a5%e9%94%81>#</a></h2><p><code>Go</code> 语言中互斥锁的用法如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span> <span style=color:#75715e>//互斥锁
</span><span style=color:#75715e></span><span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Lock</span>() <span style=color:#75715e>//加锁
</span><span style=color:#75715e></span><span style=color:#a6e22e>s</span> = append(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>i</span>)
<span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Unlock</span>() <span style=color:#75715e>//解锁
</span></code></pre></div><p>在访问临界区的前后加上互斥锁，就可以保证不会出现并发问题。</p><p>我们修改还是上一个<code>4.7.1</code>的例子，为其增加互斥锁。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s</span> []<span style=color:#66d9ef>int</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>

<span style=color:#a6e22e>appendValueSafe</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) {
    <span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Lock</span>()
    <span style=color:#a6e22e>s</span> = append(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>i</span>)
    <span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Unlock</span>()
}

<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> { <span style=color:#75715e>//10000个协程同时添加切片
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>appendValueSafe</span>(<span style=color:#a6e22e>i</span>)
}
<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>2</span>)
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(len(<span style=color:#a6e22e>s</span>))
</code></pre></div><ul><li>对共享变量<code>s</code>的写入操作加互斥锁，保证同一时刻只有一个<code>goroutine</code>修改内容。</li><li>加锁之后到解锁之前的内容，同一时刻只有一个访问，无论读写。</li><li>无论多少次都输出<code>10000</code>，不会再出现竞态问题。</li><li>要注意：<strong>如果在写的同时，有并发读操作时，为了防止不要读取到写了一半数据，需要为读操作也加锁。</strong></li></ul><h2 id=473-读写锁>4.7.3 读写锁
<a class=anchor href=#473-%e8%af%bb%e5%86%99%e9%94%81>#</a></h2><p>互斥锁是完全互斥的，并发读没有修改的情况下是不会有问题的，也没有必要在并发读的时候加锁不然效率会变低。</p><p>用法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>rwlock</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>
<span style=color:#75715e>//读锁
</span><span style=color:#75715e></span><span style=color:#a6e22e>rwlock</span>.<span style=color:#a6e22e>RLock</span>()
<span style=color:#a6e22e>rwlock</span>.<span style=color:#a6e22e>RUnlock</span>()

<span style=color:#75715e>//写锁
</span><span style=color:#75715e></span><span style=color:#a6e22e>rwlock</span>.<span style=color:#a6e22e>Lock</span>()
<span style=color:#a6e22e>rwlock</span>.<span style=color:#a6e22e>Unlock</span>()
</code></pre></div><p>并发读不互斥可以同时，在一个写锁获取时，其他所有锁都等待， 口诀：读读不互斥、读写互斥、写写互斥。具体测算速度的代码可以见4.7.3的源码，感兴趣的可以改下注释位置看下效率是有很明显的提升的。</p><h2 id=474-小结>4.7.4 小结
<a class=anchor href=#474-%e5%b0%8f%e7%bb%93>#</a></h2><ul><li>学习了几个名词：临界区、竞态问题、互斥锁、原子操作、读写锁。</li><li>互斥锁：<code>sync.Mutex</code>, 读写锁：<code>sync.RWMutex</code> 都是 <code>sync</code> 包的。</li><li>读写锁比互斥锁效率高。</li></ul><p>问题：只加写锁可以吗？为什么？</p><h2 id=引用>引用
<a class=anchor href=#%e5%bc%95%e7%94%a8>#</a></h2><ul><li><a href=https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81.html>并发安全和锁</a></li><li><a href=https://zhuanlan.zhihu.com/p/511128412>关于go的并发安全</a></li><li><a href=https://blog.csdn.net/weixin_43851310/article/details/87897247>golang_并发安全: slice和map并发不安全及解决方法</a></li></ul></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=minibear2333/blog-comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/golang-minibear2333/golang/edit/master/./4.concurrent/4-7-lock.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#471-并发不安全的例子>4.7.1 并发不安全的例子</a></li><li><a href=#472-互斥锁>4.7.2 互斥锁</a></li><li><a href=#473-读写锁>4.7.3 读写锁</a></li><li><a href=#474-小结>4.7.4 小结</a></li><li><a href=#引用>引用</a></li></ul></nav></div></aside></main></body></html>